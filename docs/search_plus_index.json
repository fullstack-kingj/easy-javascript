{"./":{"url":"./","title":"前言","keywords":"","body":" 使用 GitBook 在线阅读本课程 前言 本套课程共分为 10 个章节，从基础的概念到具体的用法，逐一详细的进行阐述。目的就是努力成为最好的 JavaScript 自学课程。 本套课程会一直更新，直到达到适合于所有人自学为止。 10 个章节内容，大体上可以被分为以下几个部分内容: 说明: 如果你已经掌握 JavaScript 中的部分内容，可以根据自己的情况选择性的进行学习。 第一部分: 概念 我们首先从第一章节概念入手，先掌握什么是 JavaScript、JavaScript 的运行环境以及如何进行代码调试。 这部分内容，是你学习 JavaScript 中后续内容的基础。概念清晰了，操作才会更顺手。学习概念，不仅仅只是单纯地阅读文字这么简单。要试着用自己的话来描述你所学习的概念，并把它发布到网络上，让别人替你检查，你的理解是否准确。 如果你不知道如何发布到网络上，可以加入底部的 QQ 讨论群，与其他人共同学习。 第二部分: 基础语法 从第二章到第五章，我们要掌握有关 JavaScript 的一些基础语法。这部分内容包含了一些最基本的语法内容、变量与常量、数据类型和运算符。 不要小瞧 JavaScript 的基础语法内容，这部分内容是我们学习使用 JavaScript 编程的根本。很多读者在学习这部分内容的时候，经常会忽略一些细节。这些往往都是将来我们使用 JavaScript 编程所遇到的错误。 这部分内容，作者会不断地更新补充。尽量做到面面俱到，让你在学习之后可以全面地掌握 JavaScript 的基础语法内容。 你可以 star 或者 watch 本课程，这样一旦有更新，GitHub 会通知你。 第三部分: 核心语法 这部分内容是从第六章到第十章，我们要掌握有关 JavaScript 的核心语法内容。这部分内容包含了语句、数组、函数、作用域以及对象。 学习这部分内容，需要读者既要理解概念，又要消化原理流程，还要动手进行操作。所以，这部分内容应该是本套课程最核心的部分，也是最难掌握的部分。 不过，不要灰心! 作者会在后续的更新中，加入大量适当的案例，帮助你更好地掌握这部分内容。 你可以 star 或者 watch 本课程，这样一旦有更新，GitHub 会通知你。 反馈 本套课程会尽量完善，编写过程中难免出现纰漏。你可以通过以下展示方式进行反馈，作者会根据反馈及时更新和修改。 交流 你可以扫描下方的二维码，加入本套课程的 QQ 讨论群，与其他童鞋一起学习交流。 版权 本套课程的文本内容免费开源，任何人都可以免费学习、分享，甚至可以进行修改。但需要注明作者及来源，并且不能用于商业。 本套课程采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-02-05 15:14:09 "},"chapter1/javascript-summary.html":{"url":"chapter1/javascript-summary.html","title":"第一章 JavaScript 是什么","keywords":"","body":"JavaScript 语言是一门跨平台、面向对象的轻量级脚本语言，运行于 JavaScript 解释器/引擎。 JavaScript 语言内置了一个包含一系列对象的标准库，比如数组、日期、数学和一个语言元素集合包括操作符、流程控制及语句等内容。 JavaScript 解释器是作为 JavaScript 脚本代码的运行环境，如下述两种呈现方式: 独立安装的 JavaScript 解释器。 嵌入在浏览器内核中的 JavaScript 解释器。 JavaScript 简史 1992 年，Nombas 公司为自己的 CEnvi 软件开发了一款脚本语言 ScriptEase，可以嵌入在网页中。 1995 年， Netscape 公司为自己的 Navigator2.0 浏览器开发了另一种客户端脚本语言 Livescript，为了搭上当时很热 Java 的顺风车，临时把 LiveScript 改名为 JavaScript。 1996 年，Microsoft 公司在 IE3 中加入了 JScript（为避开 JavaScript 的版权问题）。 1997 年，JavaScript 1.1 作为草案提交给 ECMA（欧洲计算机制造商协会），完成了 ECMA-262 —— 定义了名为 ECMAScript 的脚本语言标准。 JavaScript 实现 虽然 JavaScript 与 ECMAScript 经常被认为是相同含义，但 JavaScript 的含义要比 ECMAScript 多。一个完整的 JavaScript 实现应该由下列三个不同的部分组成: 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM） JavaScript 应用 客户端 JavaScript 通过提供控制浏览器及其文档对象模型（DOM）的对象来扩展语言核心。例如: 客户端版本直接支持应用将元素放在 HTML 表单中并且支持响应用户事件，比如鼠标点击、表单提交和页面导航。 服务器端 JavaScript 通过提供有关在服务器上运行 JavaScript 的对象来可扩展语言核心。例如: 服务端版本直接支持应用和数据库通信，提供应用不同调用间的信息连续性，或者在服务器上执行文件操作。 与 JScript 的关系 JScript 是 Microsoft 公司为 IE3 浏览器添加的脚本语言，也是 JavaScript 的另一种实现，只是 Microsoft 公司为了避免与 Netscape 公司的 JavaScript 语言产生版权问题，而命名为 JScript。 至此，JavaScript 实现意味着存在两个不同的版本: Netscape 公司的 JavaScript 和 Microsoft 公司的 JScript，当时没有任何标准规定 JavaScript 的语法和特性，导致开发人员在使用 JavaScript 的时候需要考虑浏览器的兼容性问题。 直到以 JavaScript 1.1 为草案提交给 ECMA（欧洲计算机制造商协会）定义了 ECMA 标准，这个问题才得以缓解。 参考资料: MSDN 提供的 JavaScript 语言参考 与 Java 的关系 JavaScript 经常被误解为是 Java 的子集，实际上，这两种语言是完全不相干的。 JavaScript 与 Java 的语法很相似，就像 Java 和 C 语言的语法相似一样。JavaScript 最初被设计为运行在浏览器中的脚本语言，而 Java 是一种跨平台语言，目前主要应用于服务器端运行。 JavaScript 随着 Netscape 公司的战略而改变为 LiveScript，直到 1995 年 12 月 Netscape 公司与 SUN 公司才正式、公开地发布声明，LiveScript 语言更改为 JavaScript。 而 JavaScript 之所以改名，只是因为当时的 Java 语言很火而已。 ECMAScript 介绍 JavaScript 的核心语言是 ECMAScript，ECMAScript 是由 ECMA（欧洲计算机制造商协会）定义的标准化脚本语言，与 Web 浏览器没有依赖关系。ECMAScript 不仅可以运行在内建 JavaScript 引擎的浏览器中，也可以运行在独立的 JavaScript 解释器中（例如 Node.js）。 ECMAScript 规定了下列组成部分：语法、类型、语句、关键字、保留字、操作符及对象等。 JavaScript 实现了 ECMAScript，其他脚本语言同样实现了 ECMAScript（例如 Adobe 公司的 ActionScript 语言）。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-15 15:36:29 "},"chapter1/runtime-environment.html":{"url":"chapter1/runtime-environment.html","title":"第二节 运行环境","keywords":"","body":"JavaScript 语言目前比较主流的运行方式有两种。 一种是基于浏览器环境，这也是 JavaScript 最初也是最主流的一种运行方式。但由于目前网络环境越发复杂，可以内嵌浏览器的环境也越来越多。例如 PC 端浏览器、移动端浏览器、微信内置浏览器等。 一种是基于解释器环境，这种方式目前主要是以 Node.js 环境为主的环境。 基于浏览器 基于浏览器环境的这种方式，我们目前的测试是使用了浏览器自带的开发者工具实现的。这里我们主要测试 Chrome 浏览器和 Firefox 浏览器，当然其他浏览器也都提供了相关功能。 Chrome 浏览器 我们可以通过 Chrome 浏览器提供的开发者工具的 console 功能测试 JavaScript 代码，如下图所示: Chrome 浏览器如何开启开发者工具 1. 打开 Chrome 浏览器，点击右上角的【菜单】，如下图所示。 2. 在弹出的窗口中，选择【更多工具】中的【开发者工具】，如下图所示。 这时在 Chrome 浏览器的窗口中可以看到【开发者工具】的界面，如下图所示。 说明: Chrome 浏览器的【开发者工具】功能也可以通过快捷键方式打开，但不同操作系统的不同版本的快捷键可能不相同。 Firefox 浏览器 我们也可以通过 Firefox 浏览器提供的开发者工具的控制台功能测试 JavaScript 代码，如下图所示: Firefox 浏览器如何开启开发者工具 1. 打开 Firefox 浏览器，点击右上角的【菜单】，如下图所示。 2. 在弹出的窗口中，选择【Web 开发者】选项，如下图所示。 3. 在弹出的窗口中，选择【Web 控制台】选项，如下图所示。 这时在 Firefox 浏览器的窗口中可以看到【开发者工具】的界面，如下图所示。 说明: Firefox 浏览器的【开发者工具】功能也可以通过快捷键方式打开，但不同操作系统的不同版本的快捷键可能不相同。 基于解释器 独立的 JavaScript 解释器是非浏览器环境运行 JavaScript 脚本代码的环境。目前最流行的 JavaScript 解释器为 Node.js，Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 第一个程序 下面，我们通过 Node.js 环境运行第一个 JavaScript 程序。当然，这个程序并没有什么实际意义，只是让你先感受一下 JavaScript 语言。 1. 点击程序 Node.js，运行 Node.js 命令行模式。 2. 输入以下代码，回车进行运行，并查看结果。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 12:00:17 "},"chapter1/code-debug.html":{"url":"chapter1/code-debug.html","title":"第三节 代码调试","keywords":"","body":"代码调试，是我们使用 JavaScript 语言编程过程中一项不可缺少的环节。虽然这并不是什么技术内容，但在实际开发中，依旧起着很重要的作用。 接下来，就让我们看一看基于 Node.js 环境的一些调试手段有哪些。 console 控制台 console 用于提供控制台标准输出，它是由 Microsoft 公司的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的标准，而独立 JavaScript 解释器 Node.js 也沿用了这个标准。 方法 描述 console.log() 向标准输出流打印字符并以换行符结束 console.info() 向标准输出流打印信息性消息。输出文字外，会显示一个蓝色的惊叹号 console.warn() 向标准输出流打印警告性消息。输出文字外，会显示一个黄色的惊叹号 console.error() 向标准输出流打印错误性消息。输出文字外，会显示一个红色的叉子 如下示例代码，可在浏览器的开发者工具或者 Node.js 环境中运行: // 用于输出日志性消息 console.log(\"这是一个log日志性消息.\"); // 用于输出信息性消息 console.info(\"这是一个info信息性消息.\"); // 用于输出警告性消息 console.warn(\"这是一个warn警告性消息.\"); // 用于输出错误性消息 console.error(\"这是一个error错误性消息.\"); Node.js 调试器 基于 Chrome V8 引擎的 Node.js 解释器提供了一个强大的调试器，帮助开发人员调试应用程序。 1. 在 JavaScript 代码中添加 debugger 语句，debugger 语句相当于在代码中标注一个断点。 var str = \"这是一个测试内容.\"; // 定义一个用于测试的变量 debugger; // 添加debugger语句 console.log(str); // 输出测试内容 2. 以 debug 方式运行 JavaScript 代码: node debug debugger.js node-inspector node-inspector 模块为在 Node.js 解释器中调试 JavaScript 代码提供了另一种选择，比 Node.js 内建的 debugger 强大很多。 1. 使用 npm 安装 node-inspector 模块: npm install -g node-inspector 2. 启动 inspector 服务，实现通过浏览器连接 node-spector: node-inspector 3. 以 debug 方式运行 JavaScript 代码: node --debug-brk 03_inspector.js 4. 使用 Chrome 浏览器通过以下地址进行调试代码: http://127.0.0.1:8080/?port=5858 注意: node-inspector 模块目前只能使用 Chrome 浏览器，其他浏览器无任何效果。 附录 node-inspector 安装失败问题解决 安装失败原因: node-inspector 模块是通过 npm 方式在线安装，而 npm 的镜像是在国外，由于国内的一些特殊情况可能会导致安装失败。 解决办法: 可以使用由淘宝提供的国内 npm 镜像进行替换，保证 node-inspector 模块安装成功。 淘宝 npm 使用 1. 在命令行中输入以下命令，安装淘宝 npm 定制的 cnpm: npm install -g cnpm --registry=https://registry.npm.taobao.org 2. 通过淘宝 npm 定制的 cnpm 安装模块: cnpm install [name] 注意: 通过 npm 或 cnpm 方式安装镜像只能在线安装，所以确保当前系统环境可以连接互联网。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 12:06:52 "},"chapter2/grammar.html":{"url":"chapter2/grammar.html","title":"第二章 基础语法","keywords":"","body":"本节课程，我们将学习 JavaScript 语言的基础语法。这些虽然都是最基本的内容，但可以帮助我们养成一个良好的编程习惯。 区分大小写 JavaScript 是一种区分大小写的语言。这意味着 JavaScript 的关键字、变量名、函数名、以及任何其他的标识符必须使用一致的大小写形式。比如 longestory、Longestory 或 LONGESTORY 是不同的变量名。 var longestory = \"longestory\";// 定义longestory变量 console.log(longestory);// 打印longestory变量 var Longestory = \"Longestory\";// 定义Longestory变量 console.log(Longestory);// 打印longestory变量 var LONGESTORY = \"LONGESTORY\";// 定义LONGESTORY变量 console.log(LONGESTORY);// 打印LONGESTORY变量 注意: 在 JavaScript 中定义变量名和函数名时应该特别注意。 空格和换行 JavaScript 会忽略出现在代码中的空格、制表符和换行符。 由于可以自由地在代码中使用空格、制表符和换行符，所以采用争气、一直的缩进来形成统一的编码风格，从而提高代码的可读性显得尤为重要。 JavaScript 还可以识别水平制表符、垂直制表符、换页符等，JavaScript 将以下字符识别为行结束符: 换行符、回车符、行分隔符、段分隔符等。回车符加换行符在一起被解析为一个单行结束符。 可选的分号 JavaScript 的语句一般是以一个分号作为结尾。当然，JavaScript 也允许忽略这个分号。如果省略分号，则由解释器确定语句的结尾， 如下述示例代码所示: var sum = a + b// 即使没有分号也是有效的语句 —— 不推荐 var diff = a - b;// 有效的语句 —— 推荐 注意: 在 JavaScript 中，虽然语句结尾的分号不是必需的，但还是建议任何时候都不要省略。使用分号是一个非常好的编程习惯。 如果将上述示例代码编写在一行的话，如下示例代码所示: var sum = a + bvar diff = a - b; 上述示例代码运行的结果是报错，具体报错信息如下图所示: 注释 在编写 JavaScript 代码时，经常利用注释为代码添加说明。注释的内容会被 JavaScript 解释器/引擎忽略，JavaScript 支持两种格式的注释: 单行注释 // 这里是单行注释 多行注释 /* * 这里是多行注释 */ 注意: 上述注释的第二行是以星号开始，但这并不是必需的。 语句 JavaScript 代码将多行组合成一个代码块，每个代码块一般是以左花括号（{）开始，以右花括号（}）结束。 如下述示例代码所示: if(test){ test = false; console.log(test); } 注意: 一般在执行多行代码时才需要语句块，但最好是始终都使用花括号将代码块进行包裹。 在 JavaScript 代码中，如果独立编写一个语句的话，JavaScript 语法并不报错。如下示例代码所示: { console.log(test);// 推荐使用 } 但是，我们并不推荐这样使用。因为在 ECMAScript 5 版本中，并不存在块级作用域。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-15 16:13:22 "},"chapter2/keywords.html":{"url":"chapter2/keywords.html","title":"第二节 关键字与保留字","keywords":"","body":"JavaScript 语言的关键字和保留字，简单理解就是具有特殊含义的字符，你在定义变量、函数和对象名称时不能使用的。 注意: 随着 JavaScript 版本的更新，保留字可能会成为关键字。所以，这里所说的关键字和保留字是具有时效性的。 关键字 JavaScript 定义了一组具有特定用途的关键字，这些关键字可用于表示语句的开始或结束、或者执行特定操作等。也就是说，定义变量名或、函数名或对象名时不能使用这些名称。 保留字 JavaScript 除了定义了一组关键字，还定义了一组同样不能作为变量名、函数名或对象名的保留字。保留字可能在将来被作为新的关键字出现的。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 12:38:30 "},"chapter3/variable.html":{"url":"chapter3/variable.html","title":"第三章 变量与常量","keywords":"","body":"什么是变量 变量是存储数据信息的容器。变量被认为是有名字的容器。在代码中，使用变量名为值命名，需要遵守一定的规则。 注意: JavaScript 中的变量是弱类型的，也称之为松散类型的。所谓弱类型/松散类型就是可以用来保存任何类型的数据。 如下示例代码所示，定义了一个变量 v，并初始化值为 100，然后重新赋值为 string: var v = 100; v = \"string\"; 上述代码只是展示了变量的用法，具体的使用我们将在下面的内容中学习。 变量的声明 在 JavaScript 代码中，使用变量前应当先声明。变量是使用关键字 var 声明的。 1. 只声明未初始化，变量的值自动取值为 undefined 一行代码只声明一个变量: var sum;// 值为undefined var msg;// 值为undefined 一行代码声明多个变量: var x, y, z;// 值为undefined 2. 将变量的声明和初始化合写在一起 一行代码只声明一个变量并赋值: var sum = 100;// 值为 100 var msg = \"this is message\";// 值为 this is message 一行代码声明多个变量并赋值: var x = 0, y = 1, z = 2; 上述示例代码中变量的值，可以是不同类型。 说明: 等号（=）是赋值运算符。 命名规则 变量的命名需要遵守一定的规则的，具体规则如下: 必须以字母、数字、下划线（_）、美元符号（$）开始。 不能以数字开头。 不能使用关键字和保留字作为名称。 由于 JavaScript 是区分大小写的，大写字母与小写字母并不冲突。 名称最好有明确的含义。 可以采用“匈牙利命名法”、“下划线命名法”、“小驼峰命名法”或“大驼峰命名法” 之一，在开发团队内进行协调统一。 如下示例代码所示，展示了几种变量的命名方式: var longeStory = 'longestory';// 小驼峰方式命名 var LoneStory = 'longestory';// 大驼峰方式命名 var longe_story = 'longestory';// 下划线方式命名 建议: 在一个项目案例中，尽量保持一种命名方式。 声明的问题 1. 重复的声明 使用 var 关键字重复声明变量是合法且无害的。但是如果重复声明并初始化的，这就表示重复声明并初始化。由于 JavaScript 变量只能存储一个数据，之前存储的数据会被覆盖。 var msg = \"this is message\";// 值为 this is message var msg = 100;// 值为 100 2. 遗漏的声明 直接读取一个没有声明的变量的值，JavaScript 会报错。 console.log(str);// str 变量并没有声明 上述代码运行结果为报错，具体报错信息如下图所示: 注意: 为一个没有声明的变量初始化，是合法的，但并不推荐这样使用。 变量的使用 对声明的变量既可以读取操作，也可以赋值操作。 1. 读取操作 如下示例代码所示，分别测试了只定义未初始化的变量和定义并初始化的变量的调用: var message;// 只声明未初始化 console.log(message);// 输出 undefined var msg = “this is message”;// 声明并初始化 console.log(msg);// 输出 this is message 这里是通过变量名找到变量对应存储的数据内容。我们真正使用的是数据内容，而不是变量。 2. 赋值操作 如下示例代码所示，分别测试了为一个未初始化的变量赋值，和为一个已初始化的变量重新赋值: var message;// 只声明未初始化 message = \"this is message\";// 初始化操作 var msg = \"this is message\";// 值会被覆盖 msg = \"this is another message\";// 重新赋值 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 12:59:23 "},"chapter3/constant.html":{"url":"chapter3/constant.html","title":"第二节 常量","keywords":"","body":"什么是常量 常量就是一个只读（read-only）的变量。常量与变量类似，同样用于存储数据信息。只是常量的数据一旦被定义，便不能被修改。 常量的声明 在 ECMAScript 5 版本前，没有定义常量的语法。使用 var 关键字定义变量，人为规定值不改变，也可以是不严格的常量。如下示例代码所示: var MY_CONST = 10; 说明: 常量名习惯使用全大写形式。 这种方式只是人为规定常量，并不是语法规定。所以，这种方式定义的常量并不严谨！ 在 ECMAScript 5 版本后，提供了关键字 const 定义常量。如下示例代码所示: const MY_CONST = 100; 注意: 常量的声明，必须进行初始化操作，否则会报错误。 const MY_CONST; // SyntaxError: missing = in const declaration 上述示例代码的运行结果为报错，具体的报错信息如下图所示: 说明: 如果定义常量时，省略了关键字 const 的话，JavaScript 会认为是一个变量。 常量的使用 常量一旦被声明并初始化，值并不能被改变。常量的使用只能进行读取操作: // 定义常量 MY_CONST 并赋值 7 const MY_CONST = 7; // 在 Firefox 和 Chrome 这会失败但不会报错(在 Safari 这个赋值会成功) MY_CONST = 20; console.log(MY_CONST); // 输出 7 const MY_CONST = 20; // 尝试重新声明会报错 var MY_CONST = 20;// MY_CONST 保留给上面的常量，这个操作会失败 console.log(MY_CONST);// MY_CONST 依旧为 7 注意: 上述示例代码具有时效性，浏览器版本不同，结果可能不同。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 13:30:46 "},"chapter4/data-type.html":{"url":"chapter4/data-type.html","title":"第四章 数据类型","keywords":"","body":"在 JavaScript 语言中，能够表示并操作值的类型称之为数据类型。 数据类型可分为可变类型和不可变类型。可变类型的值是可修改的，对象和数据就属于可变类型；不可变类型的值是不可修改的，数字、布尔值、null 和 undefined 都属于不可变类型。 字符串可以看成由字符组成的数组，可能被误认为是可变的。但在 JavaScript 中，字符串的值是不可变的。 数据类型分类 根据 ECMAScript 标准中的描述，数据类型被分为如下两种类型: 原始类型（又称原始值） 引用类型（又称内置对象） 但，为了可以更好地学习 JavaScript 语言的数据类型。所以，我们将原始类型再细分为原始类型和特殊类型。 说明: 这里的特殊类型，并不是标准规范中的内容。只是为了方便我们进行区分而已。 再将引用类型细分为包装类型和引用类型。 说明: 这里的包装类型，是参考了 Java 语言中对数据类型的分类方式。 所以，这里将 JavaScript 语言的数据类型，分成了如下图所示的方式: 说明: 在本章节中，我们不会讨论引用类型。引用类型会在《JavaScript 面向对象》教程中详细讲解。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 13:32:19 "},"chapter4/primitive-type.html":{"url":"chapter4/primitive-type.html","title":"第二节 原始类型","keywords":"","body":"原始类型，又称为原始值，是直接代表 JavaScript 语言实现的最底层的数据。 原始类型分别为 boolean 类型、number 类型和 string 类型三种。当然，有些资料将 undefined 和 null 也归为原始类型（这里表示为特殊类型）。 声明变量并初始化值为原始类型，一般称之为字面量方式定义变量，也可以称之为直接量方式定义变量。 boolean 类型 布尔（boolean）类型是指真或假、开或关、是或否。这个类型只有两个值：true 和 false。 注意: 由于 JavaScript 是区分大小写的，布尔类型的 true 和 false 全部是小写。 JavaScript 也可以将其他类型的数据，自动转换为布尔类型。如下表所示，其他类型转换成 boolean 类型的情况: 数据类型 转换为 true 值 转换为 false 值 boolean 类型 true false string 类型 任何非空字符串 \"\"（空字符串） number 类型 任何非零数字值（包括无穷大） 0、0.0 和 NaN object 类型 任何对象 null undefined undefined 我们可以通过如下示例代码所示，判断当前其他类型的变量自动转换为布尔类型后的情况: var v = 0; // 这里我们使用 if...else 语句判断当前变量值自动转换成 boolean 类型后的值 if (v) { console.log('true'); } else { console.log('false'); } 其他类型转换成布尔类型虽然是固定的内容，也没有什么难度，但在实际开发中经常遇到自动转换的情况。 number 类型 number 类型是指数字值，JavaScript 语言与其他编程语言不太一样的地方是 JavaScript 语言不区分整数类型和浮点类型。 整数类型: 包括负整数、0 和正整数等。 浮点类型: 表示小数。 浮点类型 浮点类型，就是指该数值包含整数部分、小数点和小数部分的数字值。 如下示例代码所示，展示了如何定义一个浮点型变量: var floatNum1 = 0.1; var floatNum2 = .1;// 有效，但不推荐 说明: JavaScript 允许小数点前可以没有整数，但不推荐这种写法。 如果小数点后面没有任何数字，那这个数值作为整数类型保存。如下示例代码所示: var floatNum3 = 1.;// 小数点后面没有数字 —— 解析为 1 var floatNum4 = 10.0;// 整数 —— 解析为 10 说明: 保存浮点类型需要的空间是保存整数类型的两倍。 四舍五入误差 整数有无数个，但 JavaScript 通过浮点类型只能表示有限的个数（确切地说是 18 437 736 874 454 810 627 个）。也就是说，当在 JavaScript 中使用浮点类型时，常常只是真实值的一个近似表示。如下示例代码所示: var x = .3 - .2; var y = .2 - .1; x == y;// 值为false，表示两值不相等 x == .1;// 值为false，.3-.2 不等于 .1 y = .1;// 值为true，.2-.1 等于 .1 注意: 建议使用大整数表示金额。例如使用分作为单位，而不是使用元作为单位。 NaN NaN（Not a Number），即非数值，是一个特殊的数字值。其特殊的地方如下: 任何涉及 NaN 的操作都会返回 NaN。 NaN 与任何值都不相等，包括 NaN 本身。 针对上述特点，JavaScript 提供了 isNaN() 函数。该函数用于判断计算结果是否为数值。 console.log(isNaN(10));// 输出false（10是一个数值） console.log(isNaN(\"10\"));// 输出false（可以被转换成数值 10） console.log(isNaN(\"blue\"));// 输出true（不能转换成数值） console.log(isNaN(true));// 输出false（可以被转换成数值 1） string 类型 string 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，被称之为字符串。字符串可以由双引号（\"）或单引号（'）表示。 var firstString = \"www.longestory.com\"; var secondString = 'www.longestory.com'; 说明: 在 JavaScript 语言中，使用双引号（\"\"）或单引号（''）定义字符串是没有区别的。我们建议使用单引号（''）。 string 类型包含一些特殊的转义字符，用于表示非打印字符。 转义字符 含义 \\n 换行符 \\t 制表符 \\b 退格符 \\r 回车符 \\f 换页符 \\ 斜杠 \\' 单引号（'），在用单引号表示的字符串中使用 \\\" 双引号（\"），在用双引号表示的字符串中使用 typeof 运算符 由于 JavaScript 是弱类型/松散类型的，因此需要有一种手段来检测给定变量的数据类型。typeof 运算符就是负责提供这方面信息，如下示例代码所示: var message = \"www.longestory.com\"; console.log(typeof message);// 输出 string console.log(typeof(message));// 输出 string 注意: typeof 运算符加上圆括号，会像是函数，而不是运算符，并不建议这种写法。 值 类型 true 或 false boolean 任意字符串 string 任意数字或 NaN number Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 13:56:19 "},"chapter4/wrapper-type.html":{"url":"chapter4/wrapper-type.html","title":"第三节 包装类型","keywords":"","body":"在 JavaScript 中，对应原始类型提供了包装类型。通过包装类型可以创建原始类型的对象。 由于 JavaScript 是区分大小写的，从写法上来说，原始类型是全部小写，包装类型则是首字母大写。 一般不建议使用包装类型定义对应的数据类型，但包装类型提供了操作相应值的方法。 说明: 包装类型涉及到对象的概念，具体技术内容会在后面的课程学习。 Boolean 类型 Boolean 类型是原始类型 boolean 类型对应的包装类型。如下示例代码所示，同样可以定义一个布尔类型的变量: var bool = new Boolean(true); Boolean 类型与 boolean 类型的区别: typeof 运算符对原始类型返回的结果为 boolean，而对包装类型返回的结果为 object。 instanceof 运算符测试 Boolean 类型返回 true，而测试 boolean 类型返回 false。 注意: 不建议使用 Boolean 类型。 Number 类型 Number 类型是原始类型 number 类型对应的包装类型。如下示例代码所示，同样可以定义一个 Number 类型的变量: var num = new Number(10); Number 类型与 number 类型的区别: typeof 运算符对原始类型返回的结果为 number，而对包装类型返回的结果为 object。 instanceof 运算符测试 Number 类型返回 true，而测试 number 类型返回 false。 注意: 不建议使用 Number 类型。 String 类型 String 类型是原始类型 string 类型对应的包装类型。如下示例代码所示，同样可以定义一个 String 类型的变量: var str = new String('hello world'); String 类型与 string 类型的区别: typeof 运算符对原始类型返回的结果为 string，而对包装类型返回的结果为 object。 instanceof 运算符测试 String 类型返回 true，而测试 string 类型返回 false。 注意: 不建议使用 String 类型。 instanceof 运算符 instanceof 运算符的作用是判断指定变量是否为某个引用类型（包含包装类型），该运算符的语法格式如下所示: 变量名 instanceof 引用类型 如下示例代码所示: var str = new String('www.longestory.com'); console.log(str instanceof String);// 计算结果为 true, str是 String 类型 console.log(str instanceof Object);// 计算结果为 true, 所有包装类型都是 Object 的实例 console.log(str instanceof Number);// 计算结果为 false 注意: 所有对象都是 Object 类型的实例对象，通过 instanceof 运算符判断一个对象是否为具体数据类型，也包含\"父类\"。（后面课程会学习） Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 13:56:50 "},"chapter4/special-type.html":{"url":"chapter4/special-type.html","title":"第四节 特殊类型","keywords":"","body":"undefined 和 null 值都是 JavaScript 语言中的特殊类型。在实际开发中，这两个特殊类型也是经常出现错误的地方。尤其是 null 值。 undefined JavaScript 语言中有两个表示空的数据类型，undefined 和 null，其中比较有用的是 undefined。 Undefined 类型中只有一个值，就是 undefined 值。 下列情况会返回 undefined: 只定义但未初始化的变量的值为 undefined 定义并初始化值为 undefined 的变量 函数中 return 语句的默认值为 undefined 函数中 return 语句设置值为 undefined 访问不存在的对象的属性，得到的结果为 undefined 说明: 上述得到 undefined 值的情况，我们会在相应的内容中讲解。 null null 值是 JavaScript 语言中的一个特殊类型，用于表示一个不再指向任何内存空间地址的变量。 null 值多用于释放 JavaScript 语言中的资源（变量、数组和函数等）。 注意: 使用 typeof 运算符计算 null 的话，返回的是 object。但 null 值并非 Object 类型。 var longestory = null; console.log(longestory);// 输出 null undefined 与 null undefined 与 null 的共同点是它们都是原始类型，保存在栈中。 而不同点是: undefined: 表示变量声明但未被赋值，是所有未赋值变量的默认值。一般很少主动使用。 null: 表示一个没有指向任何内存地址的变量，将来可能指向某个具体内存地址。一般用于主动释放资源。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 14:01:32 "},"chapter4/type-conversion.html":{"url":"chapter4/type-conversion.html","title":"第五节 类型转换","keywords":"","body":"数据类型转换，也是使用 JavaScript 语言编程进行遇到的操作，尤其是隐世类型转换。 隐式类型转换 由于 JavaScript 语言是弱类型/松散类型的，在任何情况下都可以强制转换。 1. 转换为字符串: 将一个值加上空字符串可以轻松转换为字符串类型。 '' + 10 === '10'; // true 2. 转换为数字: 使用一元的加号操作符，可以把字符串转换为数字。 +'10' === 10; // true 3. 转换为布尔值: 使用否操作符两次，可以把一个值转换为布尔型。 !!'foo'; // true 上述示例代码，想要正确执行的话，请使用 console.log() 方法进行输出。 显式类型转换 1. 使用 JavaScript 的包装类型的构造函数进行类型转换。 构造函数 描述 Number() 将字符串或布尔值转换为数字，如果包含非法字符，则返回 NaN String() 将数字或布尔值转换为字符串 Boolean() 将字符串或数字转换为布尔值 这里需要注意的是，任何不能正确转换为数字值的内容，转换成 Number 类型后得到的结果都是 NaN。如下示例代码所示: var str = 'www.longestory.com'; console.log(Number(str));// 输出的结果为 NaN 而布尔类型的 true 转换成数字值为 1，false 转换成数字值为 0.如下示例代码所示: console.log(Number(true));// 1 console.log(Number(false));// 0 任何其他类型转换成 String 类型后，内容是没有变化的，如下示例代码所示: console.log(String(100));// String 类型的 100 console.log(String(100.11));// String 类型的 100.11 console.log(String(true));// String 类型的 true 2. 使用数据类型的转换函数进行类型转换。 函数 描述 toString() 将数字或布尔值转换为字符串 parseInt() 将字符串或布尔值转换为整数类型 parseFloat() 将字符串或布尔值转换为浮点类型 所有类型都提供了 toString() 方法，用于转换成字符串类型。如下示例代码所示: var num = 100; console.log(num.toString());// String 类型的 100 需要注意的是，我们需要了解 parseInt() 函数和 parseFloat() 函数的区别。 无论转换之前的数字是整数还是浮点数，parseInt() 函数只会得到整数部分。如下示例代码所示: var str1 = '100'; var str2 = '100.11'; console.log(parseInt(str1));// 100 console.log(parseInt(str2));// 100 而 parseFloat() 函数则会根据实际情况而定。如果是整数，则得到的也是整数；如果是浮点数，则得到的也是浮点数。如下示例代码所示: var str1 = '100'; var str2 = '100.11'; console.log(parseFloat(str1));// 100 console.log(parseFloat(str2));// 100.11 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 14:13:03 "},"chapter5/operator-summary.html":{"url":"chapter5/operator-summary.html","title":"第五章 运算符","keywords":"","body":"JavaScript 语言提供了一组用于操作数据值的运算符，又称为操作符。这些运算符可以按照作用的不同，或者操作变量数量的不同进行分类。 运算符的分类 1. 如果按照作用的不同，运算符的分类如下所示: 算数运算符（+ - * / % ++ --） 比较运算符（> >= 逻辑运算符（&& || !） 赋值运算符（= += -= *= /= %=） 字符串连接运算符（+） 条件运算符（? :） 特殊运算符（typeof instanceof delete） 按照作用的不同进行分类，更容易理解掌握。所以，我们的教程采用这种方式进行分类。 2. 如果按照操作变量的数量的不同，运算符的分类如下所示: 一元运算符（++ -- ! typeof instanceof delete） 二元运算符（+ - / % > >= = /= %=） 三元运算符（? :） 运算符的优先级别 JavaScript 语言中的运算符，如果应用在复杂的表达式中的话，我们需要了解运算符的运算优先级别。说白了，就是先计算哪个运算符，再计算哪个运算符。 不了解运算符的计算优先级别，很可能导致最后的计算结果错误。 如下图所示，就是 JavaScript 语言的运算符的优先级别: 说明: 上述展示运算符优先级别的图，来源 MDN 社区 我们并没有必要将上图中的运算符的优先级别全部记下来。这里有个小技巧，我们只需要知道小括号的计算级别是最高的就可以了。 在实际开发中，如果需要提前进行计算的，我们可以使用小括号进行包裹。如下示例代码所示: console.log((5 + 10) * 2);// 30，而不是 25 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 14:39:58 "},"chapter5/arithmetic-operator.html":{"url":"chapter5/arithmetic-operator.html","title":"第二节 算数运算符","keywords":"","body":"JavaScript 语言中的算数运算符，是运算符中相对比较简单的一种运算符。我们可以通过下述表格描述算数运算符: 给定 A=20 B=10 条件 运算符 描述 例子 + 两个运算数相加 A + B == 30 - 第一个运算数减去第二个运算数 A – B == 10 * 两个运算数相乘 A * B == 200 / 第一个运算数除以第二个运算数 A / B == 2 % 求余运算符，计算整除后的余数 A % B == 0 ++ 增量运算符，整数值逐次加 1 A++ == 21 -- 减量运算符，整数值逐次减 1 A-- == 19 加法运算符 首先，需要说明的是加法运算符。如果两个操作数都是数字值的话，会进行加法计算。如下示例代码所示: console.log( 1 + 2 );// 输出 3 但是，如果两个操作数中出现一个或两个是字符串类型的话，会进行字符串连接计算。如下示例代码所示: console.log( 1 + '2' );// 输出 12 console.log( '1' + 2 );// 输出 12 console.log( '1' + '2' );// 输出 12 除了加法运算符以外，其他算数运算符都会将字符串类型自动转换成 Number 类型，再进行计算。如下示例代码所示: console.log( '2' - '1' );// 输出 1 在上述示例代码中，如果字符串类型的操作数中，包含的是字符内容，而并非数字的话，会导致类型转换后的结果为 NaN。如下示例代码所示: console.log( 1 - 'a' );// 输出 NaN 求余运算符 其次，需要说明的是求余运算符。所谓的求余运算符，就是用于计算两个运算数整除后的余数。如下示例代码所示: console.log( 10 % 3 );// 输出 1 console.log( -10 % 3 );// 输出 -1 console.log( 10 % -3 );// 输出 1 console.log( -10 % -3 );// 输出 -1 自增运算符 自增运算符，用于整数值逐次加 1。分别具有两种用法: 前置型: 自增运算符位于运算数之前。先加 1，再赋值。 后置型: 自增运算符位于运算数之后。先赋值，再加 1。 var x = 3; console.log( x++ );// 输出 3 console.log( x );// 输出 4 var y = 3; console.log( ++y );// 输出 4 console.log( y );// 输出 4 自减运算符 自减运算符，用于整数值逐次减 1。分别具有两种用法: 前置型: 自增运算符位于运算数之前。先减 1，再赋值。 后置型: 自增运算符位于运算数之后。先赋值，再减 1。 var x = 3; console.log( x-- );// 输出 3 console.log( x );// 输出 2 var y = 3; console.log( --y );// 输出 2 console.log( y );// 输出 2 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 14:53:11 "},"chapter5/comparison-operator.html":{"url":"chapter5/comparison-operator.html","title":"第三节 比较运算符","keywords":"","body":"JavaScript 语言中的比较运算符，主要用于比较两个操作数的是否相等，或者大小情况。我们可以通过下述表格描述比较运算符: 给定 A=20 B=10 条件 运算符 描述 例子 == 检查两个运算数的值是否相等，如果相等则结果为 true A == B 为 false != 检查两个运算数的值是否不等，如果不等则结果为 true A != B 为 true > 检查左边运算数是否大于右边运算数，如果是则结果为 true A > B 为 true >= 检查左边运算数是否大于或等于右边运算数，如果是则结果为 true A >= B 为 true 检查左边运算数是否小于右边运算数，如果是则结果为 true A 检查左边运算数是否小于或等于右边运算数，如果是则结果为 true A === 两个运算数的值相等并且类型相同时，结果为 true A === B 为 false !== 两个运算数的值不等或者类型不同时，结果为 true A !== B 为 true 说明: 字符串类型的比较，是按照 Unicode 字符编码的先后顺序进行比较。 相等与不等 首先，需要说明的是相等（==）和不等（!=）两个运算符。这两个运算符只比较操作数的值，而并不比较类型。如下示例代码所示: console.log(10 == 10);// true console.log(10 == '10');// true 上述示例代码中的第二条语句，两个操作数其中一个是 Number 类型，另一个是字符串类型，但结果依旧为 true。 undefined 和 null 比较是否相等，结果为 true。因为它们都可以用于表示空，如下示例代码所示: console.log(undefined == null);// true 全等与不全等 比较运算符中，除了提供了相等（==）和不等（!=）两个运算符，还提供了全等（===）和不全等（!==）两个运算符。这两个运算符既比较操作数的值，也比较类型。如下示例代码所示: var x = 10; var y = '10'; console.log( x == y );// 输出 true console.log( x === y );// 输出 false console.log( x != y );// 输出 false console.log( x !== y );// 输出 true isNaN() 函数 isNaN() 函数用于判断其参数是否为 NaN（非数字值）。多用于检测使用类型转换函数进行数据类型转换后的结果是否为合法的数字值。 注意: NaN 与任何值（包括自身）进行比较，结果都是 false。不能使用 == 或者 === 运算符判断某个值是否是 NaN，而只能使用 isNaN() 函数。 console.log(isNaN(parseInt('123.45a')));// 输出 true console.log(isNaN('123.45a'));// 输出 true console.log(isNaN(Number('123.45a')));// 输出 true Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 15:07:56 "},"chapter5/logical-operator.html":{"url":"chapter5/logical-operator.html","title":"第四节 逻辑运算符","keywords":"","body":"JavaScript 语言中的逻辑运算符，基本用法是用于布尔类型的计算。具体运算符如下: 逻辑与运算符（&&）: 如果两个运算数都是 true，则返回 true 逻辑或运算符（||）: 如果两个运算数中任何一个是 true，则返回 true 逻辑非运算符（!）: 如果操作数能够转换为 true 则返回 false，否则返回 true。 接下来，我们就针对这三个逻辑运算符分别进行学习。 逻辑与运算符 使用逻辑与运算符时，如果两个操作数都是布尔类型的话，只有当两个操作数都为 true 时，返回的结果才为 true，否则都为 false。如下示例代码所示: console.log( false && false );// 输出 false console.log( false && true );// 输出 false console.log( true && false );// 输出 false console.log( true && true );// 输出 true 但逻辑与运算符也可以被应用在非布尔类型的操作数。如果第一个操作数转换成布尔类型后的值为 false 的话，则返回结果为第一个操作数。否则返回的结果为第二个操作数。如下示例代码所示: // 数字值 1 和 0 转换为布尔值 true 和 false console.log( 0 && 0 );// 输出 0 console.log( 0 && 1 );// 输出 0 console.log( 1 && 0 );// 输出 0 console.log( 1 && 1 );// 输出 1 // 空字符串转换为布尔值 false，非空字符串转换为布尔值 true console.log( '' && '' );// 输出 '' console.log( '' && 'longestory' );// 输出 '' console.log( 'longestory' && '' );// 输出 '' console.log( 'longestory' && 'longestory' );// 输出 longestory 逻辑或运算符 使用逻辑或运算符时，如果两个操作数都是布尔类型的话，只有当其中一个操作数都为 true 时，返回的结果才为 true，否则都为 false。如下示例代码所示: console.log( false || false );// 输出 false console.log( false || true );// 输出 true console.log( true || false );// 输出 true console.log( true || true );// 输出 true 但逻辑与运算符也可以被应用在非布尔类型的操作数。如果第一个操作数转换成布尔类型后的值为 true 的话，则返回结果为第一个操作数。否则返回的结果为第二个操作数。如下示例代码所示: // 数字值 1 和 0 转换为布尔值 true 和 false console.log( 0 || 0 );// 输出 0 console.log( 0 || 1 );// 输出 1 console.log( 1 || 0 );// 输出 1 console.log( 1 || 1 );// 输出 1 // 空字符串转换为布尔值 false，非空字符串转换为布尔值 true console.log( '' || '' );// 输出 '' console.log( '' || 'longestory' );// 输出 longestory console.log( 'longestory' || '' );// 输出 longestory console.log( 'longestory' || 'longestory' );// 输出 longestory 逻辑非运算符 逻辑非运算符的作用，就是如果操作数可以转换成 true 的话，则返回结果为 false，否则返回结果为 true。如下示例代码所示: console.log( !true );// 输出 false 这里需要注意的是，如果操作数的类型不是布尔类型的话，使用逻辑非运算符进行计算的结果是布尔类型。如下示例代码所示: console.log( !1 );// 输出 false console.log( !'longestory' );// 输出 false 说明: 能被转换为 false 的值有 null、0、NaN、空字符串(\"\") 和 undefined。 逻辑短路原则 所谓短路原则，就是只要确定运算符前面的运算数为 true 或 false，就可以确定返回结果为 true 或 false。 1. 逻辑与运算符 逻辑与运算符前面为 false，结果都将返回逻辑与运算符前面的值。 逻辑与运算符前面为 true，结果都将返回逻辑与运算符后面的值。 2. 逻辑或运算符 逻辑或运算符前面为 false，结果都将返回逻辑或运算符后面的值。 逻辑或运算符前面为 true，结果都将返回逻辑或运算符前面的值。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 16:25:13 "},"chapter5/assign-operator.html":{"url":"chapter5/assign-operator.html","title":"第五节 赋值运算符","keywords":"","body":"JavaScript 语言中的赋值运算符用于为变量或属性进行赋值操作。如下示例代码所示: var longestory = 'longestory';// 将字符串 \"longestory\" 赋值给变量 longestory var obj = {} obj.x = 1;// 将数字值 1 赋值给 obj 对象的 x 属性 赋值运算符就是将右边操作数的计算结果赋值给左边操作数。如下示例代码所示: C = A + B;// 将 A+B 的值赋给 C 赋值扩展运算符 运算符 描述 例子 += 加等赋值运算符，将右边运算符与左边运算符相加并将运算结果赋给左边运算数 C += A 相当于 C = C + A -= 减等赋值运算符，将左边运算数减去右边运算数并将运算结果赋给左边运算数 C -= A 相当于C = C - A *= 乘等赋值运算符，将右边运算数乘以左边运算数并将运算结果赋给左边运算数 C = A 相当于C = C A /= 除等赋值运算符， 将左边运算数除以右边运算数并将运算结果赋值给左边运算数 C /= A 相当于 C = C / A %= 模等赋值运算符，用两个运算数做取模运算并将运算结果赋值给左边运算数 C %= A 相当于 C = C % A 注意: C += A 由于运行时可以进行优化，执行效率都要优于C = C + A。 我们可以通过如下示例代码，测试两种写法的耗时: var num = 0;// 定义一个操作数 var startTime1 = new Date().getTime();// 获取代码执行之前的当前时间 // 循环 1000000 次，这样更好地测试结果 for (var i=0;i 上述示例代码运行的结果，如下图所示: 说明: 这里使用的时间单位是毫秒。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 16:34:48 "},"chapter5/conditional-operator.html":{"url":"chapter5/conditional-operator.html","title":"第六节 条件运算符","keywords":"","body":"JavaScript 语言中的条件运算符的作用是，首先判断一个表达式是真或假，然后根据判断结果执行两个给定指令中的一个。 条件运算符的语法格式如下: 条件 ? 值1 : 值2 如果 条件 的计算结果为 true，则最终结果为 值1，否则结果为 值2。 说明: 作为 条件 的表达式可以是任何表达式，并且计算结果为布尔类型。 我们可以通过如下示例代码，学习条件运算符的使用方式: var age = 20; var msg = age > 18 ? \"成年人\" : \"未成年人\"; 上述示例代码运行的结果为: 成年人。 条件运算符嵌套 条件运算符中，每个表达式可以又是一个条件运算表达式，称为条件运算的嵌套。如下示例代码所示: var score = 85; var result = score >= 80 ? \"优秀\" : ( score >= 60 ? \"合格\" ：\"不合格\" ); 上述代码的执行顺序如下: 执行 score >= 60 ? \"合格\" ：\"不合格\" 条件运算符 根据上一行的计算结果，再执行 score >= 80 ? \"优秀\" : 条件运算符 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 16:52:33 "},"chapter6/statement-summary.html":{"url":"chapter6/statement-summary.html","title":"第六章 语句","keywords":"","body":"在 JavaScript 中，语句使用分号（;）进行分隔。可以在每行编写一条语句，也可以在每行编写多条语句。 语句可以被分为以下几种: 条件语句：JavaScript 解释器根据一个值判断是执行还是跳过指定语句。 循环语句：JavaScript 解释器根据一个值判断是否重复执行指定语句。 跳转语句：使 JavaScript 解释器跳转到指定语句。 注意: 建议每行编写一条语句，便于提高代码的阅读性。 JavaScript 解释器按照语句的编写顺序依次执行。 语句块 JavaScript 中使用一对花括号（{}）表示一个语句块。使用语句块为语句进行分组，这样使语句的结构清晰明了。 如下示例代码所示: { var longestory = \"www.longestory.com\"; console.log(longestory); } 注意: 语句块的结尾不需要分号。 语句块中的行都有缩进，但并不是必需的。 语句中声明变量是全局变量（后面的课程学习）。 空语句 空语句允许包含 0 条语句，JavaScript 解释器执行空语句时，不会执行任何动作。 空语句如下述示例代码所示: ; 注意: 如果有特殊目的使用空语句时，最好在代码中添加注释。这样可以更好地说明这条空语句是有用的。 流程控制语句 JavaScript 解释器按照语句的编写顺序依次执行，但也可以编写一些复杂的语句块，基本分为下述三种: Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 11:53:08 "},"chapter6/conditional-statement.html":{"url":"chapter6/conditional-statement.html","title":"第二节 条件语句","keywords":"","body":"条件语句就是指通过判断指定的计算结果，来决定是执行还是跳过指定的语句块。 如果说 JavaScript 解释器是按照代码的“路径”执行的话，那条件语句就是这条路径上的分叉点，代码执行到这里时必须选择其中一条路径继续执行。 JavaScript 提供了两种条件语句: if else 语句和 switch case 语句。 if 语句 if 语句是条件判断语句，也是最基本的流程控制语句。 我们可以通过如下示例代码，学习 if 语句的使用: var num = 5; if( num 注意: if 关键字后面的小括号不能被省略。 if 关键字后面的条件判断的结果必须是布尔值。如果结果为非布尔值的话，JavaScript 会自动转换为布尔值。 if 语句中的大括号（{}）可以被省略，但建议编写，以提高代码阅读性。 if else 语句 if else 语句是条件判断语句，但与 if 语句的执行流程并不相同。 我们可以通过如下示例代码，学习 if else 语句的使用: var score = 68; if( score 注意: if else 语句中的大括号（{}）可以被省略，但建议编写，以提高代码阅读性。 if else 语句嵌套 if else 语句支持嵌套写法，也就是说，可以在 if 或 else 后面的语句块中继续编写 if else 语句。 如下述示例代码所示: var score = 68; if( score > 90 ){ console.log(\"优秀\"); }else{ if( score >= 80 ){ console.log(\"良好\"); }else{ console.log(\"一般\"); } } else if 语句 else if 语句是在 if 语句的基础上，允许提供多个条件判断。 else if 语句实际上就是简化了的 if else 语句的嵌套写法。如下述代码: switch case 语句 switch case 语句是开关语句，但整体执行流程要比 if else 语句复杂的多。具体参考下述流程图: var num = 2; switch( num ){ case 1: console.log(\"查询余额\"); break; case 2: console.log(\"在线充值\"); break; default: console.log(\"转人工服务\"); } 注意: 在实际开发中，switch case 语句与 break 语句同时使用。 switch case 语句相对于 if else 语句执行性能更优，但也有很多需要注意的地方。 注意: switch 关键字后面的小括号、case 关键字后面的冒号都不能被省略的。 break 语句是跳出语句，一旦被执行，表示后面所有的 case 和 default 语句都不会被执行。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 12:05:21 "},"chapter6/loop-conditional.html":{"url":"chapter6/loop-conditional.html","title":"第三节 循环语句","keywords":"","body":"循环语句是一系列反复执行到复合特定条件的语句。为了更好地理解循环语句，可以将 JavaScript 代码想象成一条条的分支路径。循环语句就是代码路径中的一个回路，可以让一段代码重复执行。 while 语句 while 语句是一个基本循环语句，语法结构与 if 语句很类似。 var num = 0; while( num 注意: while 关键字后面的小括号不能被省略。 while 关键字后面的条件判断的结果必须是布尔值。如果结果为非布尔值的话，JavaScript 会自动转换为布尔值。 while 语句中的大括号（{}）可以被省略，但建议编写，以提高代码阅读性。 do while 语句 do while 语句也是一个基本循环语句，执行流程与 while 语句很类似。 var num = 0; do{ console.log( num ); num = num + 1; }while( num 注意: while 关键字后面的小括号不能被省略。 while 关键字后面的条件判断的结果必须是布尔值。如果结果为非布尔值的话，JavaScript 会自动转换为布尔值。 while 语句中的大括号（{}）可以被省略，但建议编写，以提高代码阅读性。 do while 与 while 语句的区别 do while 语句与 while 语句的差别极小: do while 语句: 先执行，再判断。 while 语句: 先判断，再执行。 当 while 关键字后面的条件第一次被执行的时候，如果返回结果是 false 的话: while 语句的语句块一次都不会被执行；而 do while 语句的语句块至少被执行一次。 for 语句 for 语句是一种最简洁的循环语句，其中包含三个重要部分: 初始化表达式: 初始化一个计数器，在循环开始前计算初始状态。 条件判断表达式: 判断给定的状态是否为 true。如果条件为 true，则执行语句块，否则跳出循环。 循环操作表达式: 改变循环条件，修改计数器的值。 for 语句的语法如下: if( 初始化表达式; 条件判断表达式; 循环操作表达式 ){ 语句块 } for 语句的特殊用法 for 语句的三个表达式都是允许为空的。 1. 初始化表达式为空的情况 初始化表达式 if( ; 条件判断表达式; 循环操作表达式 ){ 语句块 } 2. 循环操作表达式为空的情况 if(初始化表达式; 条件判断表达式; ){ 语句块 循环操作表达式 } 循环嵌套 循环嵌套就是在一个循环语句中包含另一个循环语句。 for( var i = 1; i 注意: JavaScript 中对循环嵌套的层级没有任何限制。但一般建议循环嵌套三层，不然执行的性能会下降。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 12:23:23 "},"chapter6/goto-conditional.html":{"url":"chapter6/goto-conditional.html","title":"第四节 跳转语句","keywords":"","body":"JavaScript 中另一种语句就是跳转语句。从名称就可以看出，它使得 JavaScript 代码的执行可以从一个位置到另一个位置。 跳转语句提供了 break 和 continue 两种，用于跳转当前的循环或开始下一次的循环等。 break 语句 break 语句是中断语句，用于终止循环语句或开关语句。 1. 终止循环语句，例如 while、do while 以及 for 语句等 for( var i = 0; i 2. 终止开关语句（switch case） continue 语句 continue 语句是连续语句，用于重新开始 while、do while 和 for 语句。 for( var i = 0; i 上述代码的执行结果为 1 2 3 4 6 7 8 9。当 i 等于 5 时，结束本次循环，开始下一次的循环执行。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 12:25:45 "},"chapter7/one-dimensional-array.html":{"url":"chapter7/one-dimensional-array.html","title":"第七章 数组","keywords":"","body":"数组是值的有序集合。数组中的每个值叫做一个元素，而每个元素在数组中都有一个唯一的位置。这个位置用数字表示，叫做索引数据；用字符串表示，叫做关联数组。 JavaScript 数组是无类型的: 数组的元素可以是任何类型，例如字符串、数字值、布尔值等，而且每个数组中的不同元素可能是不同类型。 JavaScript 数组是动态的: 根据需要，可以动态地向数组插入新的元素，或者从数组中删除指定的元素。 定义数组 数组的最大作用就是用于存储多个值。定义数组分别三种形式: 1. 使用数组字面量方式 使用数组字面量方式，如下示例代码所示: var arr = []; 上述示例代码，表示定义了一个空数组。所谓空数组，就是没有包含任何元素的数组。 当然，我们也可以在定义数组时，同时为数组定义内部的元素。如下示例代码所示: var arr = [ 1, \"a\", true ]; 说明: 在一个数组中的不同元素可以是不同数据类型。 这里需要注意的是，虽然数组具有字面量方式的定义，但与原始类型的字面量方式的定义不同。如果使用 typeof 运算符判断数组的结果为 object，如下示例代码所示: console.log(typeof arr);// object 所以，数组只能使用 instanceof 运算符才能准确判断其类型，如下示例代码所示: console.log(typeof arr);// object 2. 使用数组函数方式 使用数组函数方式,如下示例代码所示: var arr = Array(); 上述示例代码，表示定义了一个空数组。 当然，我们也可以在定义数组时，同时为数组定义内部的元素。如下示例代码所示: var arr = Array( 1, \"a\", true); 上述示例代码，表示定义一个 arr 数组，其内部元素分别为 1、'a' 和 true。但需要注意的是如下示例代码所示的定义方式: var arr = Array( 10 ); 上述示例代码，表示定义了一个长度为 10 的空数组，并不是表示数组元素为 10。 说明: 我们并不推荐这种方式定义数组。 3. 使用构造函数方式 使用构造函数方式，如下示例代码所示: var arr = new Array(); 上述示例代码，表示定义了一个空数组。 当然，我们也可以在定义数组时，同时为数组定义内部的元素。如下示例代码所示: var arr = new Array( 1, \"a\", true); 上述示例代码，表示定义一个 arr 数组，其内部元素分别为 1、'a' 和 true。但需要注意的是如下示例代码所示的定义方式: var arr = new Array( 10 ); 上述示例代码，表示定义了一个长度为 10 的空数组，并不是表示数组元素为 10。 数组种类 索引数组 索引数组就是存储元素的位置使用数字值来表示，一般称之为索引值。具体创建方式如下示例代码所示: var arr = []; arr[0] = 1; arr[1] = \"a\"; arr[2] = true; 注意: 索引数组的索引值是从 0 开始的。 关联数组 关联数组就是存储元素的位置使用字符串来表示，一般称之为名称（name或key）。具体创建方式如下示例代码所示: var arr = []; arr['num'] = 1; arr['str'] = \"a\"; arr['bool'] = true; 注意: 关联数组的名称（name或key）是字符串，必需使用单引号或双引号将其包裹。 关联数组这个概念，并不属于 ECMAScript 5 这个版本的标准规范内容。但实际测试的结果表示，这种数组在 JavaScript 语言中是可以使用的。所以，为了方便记忆，我们参考了其他编程语言中的描述。 var arr = []; arr['num'] = 1; arr['str'] = \"a\"; arr['bool'] = true; console.log(arr.length);// 0 通过上述示例代码的测试，我们得知定义的关联数组的长度为 0。长度与数组内部元素的数量是不对应的，这表明了 JavaScript 语言中的标准规范并没有提供这种数组。 稀疏数组 稀疏数组就是包含 0 开始的不连续索引的数组。具体创建方式如下示例代码所示: var arr = Array( 10 );// 数组没有任何元素，数组的长度为 10 var arr = new Array( 10 );// 数组没有任何元素，数组的长度为 10 var arr = [];// 创建一个空数组 arr[100] = \"a\";// 向下标为 100 的位置添加一个元素 a 注意: 上述代码中的第一条和第二条语句，并不是创建一个数组包含一个元素 10，而是创建一个不包含任何元素的数组长度为 10。 数组的长度 每个数组都有一个 length 属性，表示数组的长度（即数组元素的个数）。 如果为非稀疏数组的话，length 属性的值表示当前数组包含元素的个数。 var arr1 = [ 1, \"a\", true ]; console.log( arr1.length );// 输出 3 如果为稀疏数组的话，length 属性的值大于当前数组包含元素的个数。 var arr2 = []; arr2[14] = \"a\"; console.log( arr2.length );// 输出 15 数组元素的读取 数组的主要作用是用于存储和读取数据信息，之前已经对数组存储数据信息掌握了。下面来看看如何从数组中读取指定的元素: var arr = [ 1, \"a\", true]; console.log( arr[1] );// 输出字符串 a var arr = []; arr['num'] = 1; arr['str'] = \"a\"; arr['bool'] = true; console.log( arr['str'] );// 输出字符串 a 数组元素的修改 不仅可以从数组中读取指定的元素，还可以根据需求修改数组中指定的元素值。 var arr = [ 1, \"a\", true]; console.log( arr[1] );// 输出字符串 a arr[1] = \"b\"; console.log( arr[1] );// 输出字符串 b var arr = []; arr['num'] = 1; arr['str'] = \"a\"; console.log( arr['str'] );// 输出字符串 a arr['str'] = \"b\"; console.log( arr['str'] );// 输出字符串 b 数组元素的删除 不仅可以根据需求修改数组中指定的元素值，也可以删除数组中指定的元素值。数组删除指定元素值使用 delete 关键字。 var arr = [ 1, \"a\", true]; delete arr[1]; console.log( arr[1] );// 输出字符串 undefined 注意: 上述代码使用 delete 关键字执行删除数组元素值的操作时，并不影响数组的长度。 var arr = [ 1, \"a\", true]; delete arr[1]; console.log( arr.length );// 输出 3 遍历数组元素 使用 for 语句是遍历数组元素最常见的方法: var arr = [ 1, \"a\", true]; for( var i = 0; i 也可以从数组的最后向前（倒序）进行遍历: var arr = [ 1, \"a\", true]; for( var i = arr.length-1; i >= 0; i-- ){ console.log( arr[i] ); } for in 语句 在 ECMAScript 5 中新增了 for in 语句，同样也可以用于遍历数组: var arr = [ 1, \"a\", true]; for( var i in arr ){ console.log( i + \" : \" + arr[i] ); } 注意: for 关键字后定义的变量 i 表示当前数组的索引值。 for in 语句不仅会遍历数组的所有元素，还有一些数组自带的属性。一般建议使用 for 语句进行数组遍历。 for in 语句还可以用于遍历稀疏数组，循环的每次将一个有效元素返回。不存在的索引将不会遍历到: var arr = []; arr[100] = \"a\"; for( var i in arr ){ console.log( i + \" : \" + arr[i] ); } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 17:22:58 "},"chapter7/two-dimensional-array.html":{"url":"chapter7/two-dimensional-array.html","title":"第二节 二维数组","keywords":"","body":"数组是可以嵌套的，这就意味着一个数组可以作为一个元素被包含在另外一个数组里面。利用 JavaScript 这个特点，创建二维数组，即数组的数组。 定义二维数组 定义二维数组时，可以使用定义一维数组的三种中任意一种方式进行定义。这里我们只选择其中一种方式进行讲解。 定义一个规整的二维数组 所谓的规整的二维数组，就是指作为外层数组的元素的内部数据中元素的个数是一致的。如下示例代码所示: var arr = [ [11,12,13], [21,22,23], [31,32,33] ]; 定义一个不规整的二维数组 所谓的不规整的二维数组，就是指作为外层数组的元素的内部数据中元素的个数是不一致的。如下示例代码所示: var arr = []; arr[0] = [ 101 ]; arr[1] = [ 201, 202 ]; arr[2] = [ 301, 302, 303 ]; 使用二维数组 操作二维数组中的具体元素 读取二维数组中真正的元素内容，需要连续使用两个索引值才能实现。第一个索引值表示外层数组的，第二个索引值表示内部数组的。如下示例代码所示: var arr = [ [11,12,13], [21,22,23], [31,32,33] ] ; console.log( arr[0][0] );// 值为11 arr[1][2] = 230;// 把23更改为230 遍历二维数组 遍历二维数组需要使用嵌套结构的循环语句才能实现。外部循环语句是遍历外层数据的，内部循环语句是遍历内部数组的。如下示例代码所示: for( var i = 0; i Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 17:31:25 "},"chapter8/function.html":{"url":"chapter8/function.html","title":"第八章 函数","keywords":"","body":"函数是这样的一段 JavaScript 代码，它只定义一次，但可能被执行或调用多次。简单来说，函数就是一组可重用的代码，你可以在你程序的任何地方调用他。 例如如下示例代码所示: function fn(){ console.log(\"this is function\"); } 说明: 这里只是展示了如何定义一个函数，并不需要掌握。 函数定义 函数的定义方式中，其中两种是如下方式: 1. 函数声明方式 function fn(){ console.log(\"this is function\"); } 2. 字面量表达式 var fun = fnction(){ console.log(\"this is function\"); } 函数调用 定义一个函数并不会自动的执行它。定义了函数仅仅是赋予函数以名称并明确函数被调用时该做些什么。调用函数才会真正执行这些动作。 例如下述代码: 定义一个函数fn function fn(){ console.log(\"this is function\"); } 调用函数 fn fn();// 输出字符串 this is function 函数参数 函数的参数就相当于在函数中使用的变量（虽然这个比方不是很准确）。JavaScript 中的函数定义并未制定函数参数的类型，函数调用时也未对传入的参数做任何的类型检查。 函数的参数可以分为以下两种: 形参: 出现在函数定义文法中的参数列表是函数的形式参数，简称形参。简单来说，就是定义函数时使用的参数就是形参。 实参: 函数调用时实际传入的参数是函数的实际参数，简称实参。简单来说，就是调用函数时使用的参数就是实参。 注意: 一般情况下，形参与实参的个数是相同的。但在 JavaScript 中并不强求这一点，在特殊情况下，函数的形参和实参的个数可以不相同。 function fn( one, two ){ console.log( one + two ); } fn( 1, 2 );// 输出 3 上述代码中，定义函数 fn 时，one 和 two 就是函数的形参；调用函数 fn 时，1 和 2 就是函数的实参。 return 语句 函数还可以包含一个返回语句（return）。当然，这并不是必需的。return 语句使函数可以作为一个值来使用。具体用法如下述代码: function fn( msg ){ return \"hello\" + msg; } // 变量 fun 的值为 hello longestory var fun = fn(\"longestory\"); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-16 17:37:04 "},"chapter8/predefined-function.html":{"url":"chapter8/predefined-function.html","title":"第二节 预定义函数","keywords":"","body":"预定义函数 JavaScript 预定义了一组函数，又称为全局函数，允许直接使用。 函数 描述 eval() 对一串字符串形式的JavaScript代码字符求值 uneval() 创建的一个Object的源代码的字符串表示 isFinite() 判断传入的值是否是有限的数值 isNaN() 判断一个值是否不是数字值 parseInt() 解析字符串参数，并返回指定的整数 parseFloat() 解析字符串参数，并返回一个浮点数 decodeURI() 对已编码的统一资源标识符(URI)进行解码，并返回其非编码形式 encodeURI() 对统一资源标识符(URI)进行编码，并返回编码后的URI字符串 eval() 函数 eval() 函数用于执行以字符串（String）形式出现的 JavaScript 代码。此函数可以实现动态的执行 JavaScript 代码。具体用法如下述代码: // 定义一个字符串，内容为JavaScript代码 var js = \"console.log('this is javascript')\"; // 通过 eval()函数执行上述内容 eval(js);// 输出 this is javascript 字符编码与解码 encodeURI() 函数可把字符串作为 URI 进行编码。对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的: , / ? : @ & = + $ # decodeURI() 函数可对 encodeURI() 函数编码过的 URI 进行解码。 decodeURI() 函数和encodeURI() 函数的具体用法如下述代码: var uri = \"http://www.longestory.com/Web前端开发工程师\"; var encode = encodeURI( uri ); // 输出 http://www.longestory.com/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88 console.log( encode ); var decode = decodeURI( encode ); // 输出 http://www.longestory.com/Web前端开发工程师 console.log( decode ); 对以下在 URI 中具有特殊含义的 ASCII 标点符号，可以使用 encodeURIComponent() 函数和 decodeURIComponent() 函数。 var uri = \"http://www.longestory.com/font-end-developer\"; var encode = encodeURIComponent( uri ); // 输出 http%3A%2F%2Fwww.longestory.com%2Ffont-end-developer console.log( encode ); var decode = decodeURIComponent( encode ); // 输出 http://www.longestory.com/font-end-developer console.log( decode ); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 14:52:03 "},"chapter9/scope-summary.html":{"url":"chapter9/scope-summary.html","title":"第九章 作用域","keywords":"","body":"变量和函数都具有作用域。作用域就是变量和函数的可被访问的范围，控制着变量和函数的可见性和生命周期。 变量的作用域可被分为全局作用域和函数作用域（局部作用域）。如果变量是被定义在全局作用域的话，在 JavaScript 代码中的任何位置都可以访问该变量；如果变量是被定义在指定函数内部的话，在 JavaScript 代码中只能在该函数内访问该变量。 函数的作用域也可被分为全局作用域和函数作用域（局部作用域）。被定义在指定函数内部的函数被称之为局部函数或内部函数。 注意: ECMAScript 6 之前的 JavaScript 没有语句块作用域。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-14 10:45:42 "},"chapter9/variable-scope.html":{"url":"chapter9/variable-scope.html","title":"第二节 变量作用域","keywords":"","body":"全局变量 在所有函数之外声明的变量，叫做全局变量，因为它可被当前文档中的其他代码所访问。具体内容如下述代码所示: var msg = \"this is message\";// 定义全局变量 msg // 在全局作用域访问变量 msg console.log( msg );// 输出 this is message function fn(){ // 在函数作用域访问变量 msg console.log( msg );// 输出 this is message } fn(); 除了上述定义全局变量外，还有一种比较特殊的方式定义全局变量（具体用法如下述代码）。但这种特殊用法并不推荐！ function fun(){ // 定义变量时没有使用关键字 var longestory = \"this is longestory\"; // 在函数作用域访问变量 longestory console.log( longestory );// 输出 this is longestory } fun(); // 在全局作用域访问变量 longestory console.log( longestory );// 输出 this is longestory 局部变量 在函数内部声明的变量，叫做局部变量，因为它只能在该函数内部访问。具体用法如下述代码所示: function fun(){ // 定义局部变量 longestory var longestory = \"this is longestory\"; // 在函数作用域访问变量 longestory console.log( longestory );// 输出 this is longestory } fun(); // 在全局作用域访问变量 longestory console.log( longestory );// 输出报错 声明提前 JavaScript 变量的另一特别之处是，你可以引用稍后声明的变量，而不会引发异常。这一概念称为变量声明提升。 JavaScript 变量感觉上是被“举起”或提升到了所有函数和语句之前。然而提升后的变量将返回 undefined 值，所以即使在使用或引用某个变量之后存在声明和初始化操作，仍将得到 undefined 值。 全局变量声明提前 console.log( msg );// 不会报错，输出 undefined var msg = \"this is message\";// 定义全局变量 msg console.log( msg );// 输出 this is message 上述代码中的第一行输出不会报错，而是输出 undefined值。效果等同于如下述代码: var msg;// 定义全局变量 msg，但未初始化 console.log( msg );// 不会报错，输出 undefined msg = \"this is message\";// 初始化全局变量 msg console.log( msg );// 输出 this is message 局部变量声明提前 function fn(){ console.log( msg );// 不会报错，输出 undefined var msg = \"this is message\";// 定义全局变量 msg console.log( msg );// 输出 this is message } fn(); console.log( msg );// 输出报错 效果等同于如下述代码: function fn(){ var msg;// 定义局部变量 msg，但未初始化 console.log( msg );// 不会报错，输出 undefined msg = \"this is message\";// 定义全局变量 msg console.log( msg );// 输出 this is message } 按值传递 按值传递就是指将实参变量的值复制一份副本给函数的形参变量。JavaScript 中为函数传递参数时，都是按值传递的。 如果向函数传递的参数是原始类型数据，则在函数中修改参数变量的值，不会影响外部实参的变量。 var n = 100;// 全局变量n function fun( n ){// 参数变量也是局部变量 n -= 3;// 修改的是局部变量n console.log( n );// 输出的是局部变量n } fun( n );// 按值传递，方法内输出 97 console.log( n );// 输出全局变量的值 100 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-14 10:50:17 "},"chapter9/function-scope.html":{"url":"chapter9/function-scope.html","title":"第三节 函数作用域","keywords":"","body":"全局函数 函数与变量类似，具有全局作用域和函数作用域（局部作用域）。与全局变量类似，全局函数是被定义在全局作用域的，在任何位置都可以访问或调用该函数。 function fn( num1, num2){ console.log( num1 + num2 );// 输出 3 } fn( 1, 2 ); 内部函数 一个函数被定义在另一个函数内部，被称之为局部函数或内部函数。与变量类似，局部函数只能在当前函数的内部访问，而不能在全局作用域中被访问。 function outer(){// 全局函数 function inner(){// 局部函数 console.log(\"inner\"); } inner();// 调用正常 } inner();// 输出报错 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-14 10:51:13 "},"chapter10/object-summary.html":{"url":"chapter10/object-summary.html","title":"第十章 对象","keywords":"","body":"什么是对象 JavaScript 中的对象，和其它编程语言中的对象一样，可以比照现实生活中的对象来理解它。 JavaScript 中对象的概念可以比照着现实生活中实实在在的物体来理解。 在 JavaScript 中，一个对象可以是一个单独的拥有属性和类型的实体。拿它和一个杯子做下类比，一个杯子是一个对象，拥有属性。杯子有颜色、图案、重量等等。同样， JavaScript 对象也有属性来定义它的特征。 方法是关联到某个对象的函数，或者简单地说，一个方法是一个值为某个函数的对象属性。定义方法就象定义普通的函数，除了它们必须被赋给对象的某个属性。 对象分类 1. 内置对象/原生对象 就是 JavaScript 语言预定义的对象。在 ECMAScript 标准定义，由 JavaScript 解释器/引擎提供具体实现。 2. 宿主对象 指的是 JavaScript 运行环境提供的对象。一般是由浏览器厂商提供实现（目前也有独立的 JavaScript 解释器/引擎提供实现），主要分为 BOM 和 DOM。 3. 自定义对象 就是由开发人员自主创建的对象。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-15 15:58:14 "},"chapter10/object-object.html":{"url":"chapter10/object-object.html","title":"第二节 Object 对象","keywords":"","body":"什么是 Object 对象 Object 类型与 Array、Math 等一样都是 JavaScript 的引用类型。不过 Object 类型是 JavaScript 中所有类型的父级（所有类型的对象都可以使用 Object 的属性和方法）。 JavaScript 可以通过 Object 的构造函数来创建自定义对象。当以非构造函数形式被调用时，Object 等同于 new Object()。 Object 对象的方法 Object 对象的方法分为自有方法和原型方法两种: 1. 自有方法 方法名 描述 create() 指定原型对象和属性来创建一个新的对象 getOwnPropertyNames() 返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名 keys() 返回一个数组，包含指定对象的所有自有可遍历属性的名称 2. 原型方法 方法名 描述 prototype.hasOwnProperty() 返回一个布尔值，该值指示对象是否包含指定的属性 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-14 10:58:31 "},"chapter10/create-object.html":{"url":"chapter10/create-object.html","title":"第三节 创建对象","keywords":"","body":"对象初始化器方式 使用对象初始化器也被称作通过字面值创建对象。通过对象初始化器创建对象的语法如下: var obj = { property_1: value_1, // property_# 作为一个标示符 2: value_2, // 标示符可以是一个数字值 // ..., \"property n\": value_n // 标示符也可以是一个字符串 }; obj 是创建的对象名称。 标示符和值都是可选的。 构造函数方式 1. 通过 JavaScript 提供的预定义类型的构造函数来创建对象，如下示例: var date = new Date();// 创建一个 Date 对象 var str = new String(\"this is string.\");// 创建一个 String 对象 var num = new Number(100);// 创建一个 Number 对象 2. 通过 JavaScript 提供的 Object 类型的构造函数来创建自定义对象，如下示例: var obj = new Object();// 创建一个自定义对象 Object.create() 方法 Object.create() 方法创建一个拥有指定原型和若干个指定属性的对象。语法如下: Object.create(proto, [ propertiesObject ]) 参数: proto 参数: 一个对象，作为新创建对象的原型。 propertiesObject 参数: 可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符。 通过 Object.create() 方法创建一个新对象，同时扩展自有属性: var flyer = { name : \"A380\", speed : 1000 } var plane = Object.create( flyer,{ capacity : { value : 555, writable : true, enumerable : true } }); Object.create() 方法的一些特殊用法: 1. 创建一个原型为 null 的空对象 var obj = Object.create( null ); 2. 实现子类型构造函数的原型继承父类型构造函数的原型 Sub.prototype = Object.create( Super.prototype ); 3. 创建普通空对象 var obj = Object.create( Object.prototype ); // 等效于var o={} Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-14 11:02:43 "},"chapter10/attribute-of-object.html":{"url":"chapter10/attribute-of-object.html","title":"第四节 对象的属性","keywords":"","body":"定义对象的属性 一个 JavaScript 对象有很多属性。一个对象的属性可以被解释成一个附加到对象上的变量。对象的属性和普通的 JavaScript 变量基本没什么区别，仅仅是属性属于某个对象。 1. 可以通过点符号来访问一个对象的属性 var myCar = new Object(); myCar.make = \"Ford\"; myCar.model = \"Mustang\"; myCar.year = 1969; 2. JavaScript 对象的属性也可以通过方括号访问 对象有时也被叫作关联数组, 因为每个属性都有一个用于访问它的字符串值。 var myCar = new Object(); myCar[\"make\"] = \"Ford\"; myCar[\"model\"] = \"Mustang\"; myCar[\"year\"] = 1969; 访问对象的属性 1. JavaScript可以通过点符号来访问一个对象的属性 var emp = { ename : 'Tom', salary : 3500 }; emp.ename = 'Tommy';// 修改属性的值 console.log(emp.ename);// 获取属性的值 2. JavaScript 对象的属性也可以通过方括号访问 var emp = { ename : 'Tom', salary : 3500 }; emp[ 'ename' ] = 'Tony';// 修改属性的值 console.log(emp[ \"ename\" ]);// 获取属性的值 遍历（枚举）属性 JavaScript 提供了三种原生方法用于遍历或枚举对象的属性: for…in 循环: 该方法依次访问一个对象及其原型链中所有可枚举的属性。 Object.keys( object ) 方法: 该方法返回一个对象 o 自身包含（不包括原型中）的所有属性的名称的数组。 Object.getOwnPropertyNames( object ) 方法: 该方法返回一个数组，它包含了对象 o 所有拥有的属性（无论是否可枚举）的名称。 属性访问出错 当不确定对象是否存在、对象的属性是否存在时，可以使用错误处理结构 try…catch 语句块来捕捉抛出的错误，避免程序异常终止。 //访问未声明的变量 console.log( emp );// ReferenceEerror //访问未声明的属性 var emp = { }; console.log( emp.ename );// undefined //访问未声明的属性的成员 console.log( emp.ename.length );// TypeError 检测对象的属性 可以使用如下四种方法检测对象中是否存在指定属性: 1. 使用 in 关键字 console.log( 'ename' in emp ); 2. 使用 Object 对象的 hasOwnProperty() 方法 console.log( emp.hasOwnProperty( 'ename' )); 3. 使用 undefined 进行判断 console.log( emp.ename === undefined ); 4. 使用 if 语句进行判断 if( emp.ename ){ console.log( 'ename属性存在' ); } 删除对象的属性 可以用 delete 操作符删除一个不是继承而来的属性。如下示例: // 创建一个 myobj 对象，具有 a 和 b 属性 var myobj = new Object; myobj.a = 5; myobj.b = 12; // 删除 myobj 对象的自有属性 a delete myobj.a; Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-14 11:07:33 "},"chapter10/function-of-object.html":{"url":"chapter10/function-of-object.html","title":"第五节 对象的方法","keywords":"","body":"定义对象的方法 定义方法就象定义普通的函数，除了它们必须被赋给对象的某个属性。如下示例: var obj = new Object(); obj.sayMe = function(){ console.log( \"this is me.\" ); } var obj = { name : \"javascript\", sayMe : function(){ console.log( \"this is me.\" ); } } 调用对象的方法 对象方法的调用类似于对象属性的调用，同样具有以下两种方式: 1. 通过点符号来访问一个对象的方法 var obj = new Object(); obj.sayMe = function(){ console.log( \"this is me.\" ); } obj.sayMe();// 调用 obj 对象的 sayMe 方法 2. 也可以通过方括号访问一个对象的方法 var obj = { name : \"javascript\", sayMe : function(){ console.log( \"this is me.\" ); } } obj[ \"sayMe\" ]();// 访问 obj 对象的 sayMe 方法 删除对象的方法 可以用 delete 操作符删除对象的方法，如下示例: var obj = { name : \"javascript\", sayMe : function(){ console.log( \"this is me.\" ); } } delete obj.sayMe;// 这里没有 \"()\" 注意: 删除对象的方法时，不需要小括号“()”。如果有小括号则删除失败。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-14 11:09:30 "}}