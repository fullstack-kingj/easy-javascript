{"./":{"url":"./","title":"前言","keywords":"","body":" 在线阅读 前言 本套课程共分为 10 个章节，从基础的概念到具体的用法，一一详细的进行阐述。只为努力作为学习 JavaScript 技术的最好的自学基础课程。 本套课程会一直更新，直到达到适合于所有人自学为止。 10 个章节内容，大体上可以被分为以下几个部分内容: 说明: 如果你已经掌握 JavaScript 中的部分内容，可以根据自己的情况选择性的进行学习。 第一部分: 概念 我们首先从第一章节概念入手，先掌握什么是 JavaScript、JavaScript 的运行环境以及如何进行代码调试。 这部分内容，是你学习 JavaScript 中后续内容的基础。概念清晰了，操作才会更顺手。学习概念，不仅仅只是单纯地阅读文字这么简单。要试着用自己的话来描述你所学习的概念，并把它发布到网络上，让别人替你检查，你的理解是否准确。 如果你不知道如何发布到网络上，可以加入底部的 QQ 讨论群，与其他人共同学习。 第二部分: 基础语法 从第二章到第五章，我们要掌握有关 JavaScript 的一些基础语法。这部分内容包含了一些最基本的语法内容、变量与常量、数据类型和运算符。 不要小瞧 JavaScript 的基础语法内容，这部分内容是我们学习使用 JavaScript 编程的根本。很多读者在学习这部分内容的时候，经常会忽略一些细节。这些往往都是将来我们使用 JavaScript 编程所遇到的错误。 这部分内容，作者会不断地更新补充。尽量做到面面俱到，让你在学习之后可以全面地掌握 JavaScript 的基础语法内容。 你可以 star 或者 watch 本课程，这样一旦有更新，GitHub 会通知你。 第三部分: 核心语法 这部分内容是从第六章到第十章，我们要掌握有关 JavaScript 的核心语法内容。这部分内容包含了语句、数组、函数、作用域以及对象。 学习这部分内容，需要读者既要理解概念，又要消化原理流程，还要动手进行操作。所以，这部分内容应该是本套课程最核心的部分，也是最难掌握的部分。 不过，不要灰心! 作者会在后续的更新中，加入大量适当的案例，帮助你更好地掌握这部分内容。 你可以 star 或者 watch 本课程，这样一旦有更新，GitHub 会通知你。 反馈 本套课程会尽量完善，编写过程中难免出现纰漏。你可以通过以下展示方式进行反馈，作者会根据反馈及时更新和修改。 交流 你可以扫描下方的二维码，加入本套课程的 QQ 讨论群，与其他童鞋一起学习交流。 版权 本套课程的文本内容免费开源，任何人都可以免费学习、分享，甚至可以进行修改。但需要注明作者及来源，并且不能用于商业。 本套课程采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:48:18 "},"chapter1/javascript-summary.html":{"url":"chapter1/javascript-summary.html","title":"第一节 JavaScript 介绍","keywords":"","body":"JavaScript 是一门跨平台、面向对象的轻量级脚本语言，运行于 JavaScript 解释器/引擎。 JavaScript 内置了一个包含一系列对象的标准库，比如数组、日期、数学和一个语言元素集合包括操作符、流程控制及语句等内容。 JavaScript 解释器是作为 JavaScript 脚本代码的运行环境，如下述两种呈现方式: 独立安装的JavaScript解释器。 嵌入在浏览器内核中的JavaScript解释器。 JavaScript 简史 1992 年，Nombas 公司为自己的 CEnvi 软件开发了一款脚本语言 ScriptEase，可以嵌入在网页中。 1995 年， Netscape 公司为自己的 Navigator2.0 浏览器开发了另一种客户端脚本语言 Livescript，为了搭上当时很热 Java 的顺风车，临时把 LiveScript 改名为 JavaScript。 1996 年，Microsoft 公司在 IE3 中加入了 JScript（为避开 JavaScript 的版权问题）。 1997 年，JavaScript 1.1 作为草案提交给 ECMA（欧洲计算机制造商协会），完成了 ECMA-262 —— 定义了名为 ECMAScript 的脚本语言标准。 JavaScript 实现 虽然 JavaScript 与 ECMAScript 经常被认为是相同含义，但 JavaScript 的含义要比 ECMAScript 多。一个完整的 JavaScript 实现应该由下列三个不同的部分组成: 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM） JavaScript 应用 客户端 JavaScript 通过提供控制浏览器及其文档对象模型（DOM）的对象来扩展语言核心。例如: 客户端版本直接支持应用将元素放在 HTML 表单中并且支持响应用户事件，比如鼠标点击、表单提交和页面导航。 服务器端 JavaScript 通过提供有关在服务器上运行 JavaScript 的对象来可扩展语言核心。例如: 服务端版本直接支持应用和数据库通信，提供应用不同调用间的信息连续性，或者在服务器上执行文件操作。 与 JScript 的关系 JScript 是 Microsoft 公司为 IE3 浏览器添加的脚本语言，也是 JavaScript 的另一种实现，只是 Microsoft 公司为了避免与 Netscape 公司的 JavaScript 语言产生版权问题，而命名为 JScript。 至此，JavaScript 实现意味着存在两个不同的版本: Netscape 公司的 JavaScript 和 Microsoft 公司的 JScript，当时没有任何标准规定 JavaScript 的语法和特性，导致开发人员在使用 JavaScript 的时候需要考虑浏览器的兼容性问题。 直到以 JavaScript 1.1 为草案提交给 ECMA（欧洲计算机制造商协会）定义了 ECMA 标准，这个问题才得以缓解。 参考资料: MSDN 提供的 JavaScript 语言参考 与 Java 的关系 JavaScript 经常被误解为是 Java 的子集，实际上，这两种语言是完全不相干的。 JavaScript 与 Java 的语法很相似，就像 Java 和 C 语言的语法相似一样。JavaScript 最初被设计为运行在浏览器中的脚本语言，而 Java 是一种跨平台语言，目前主要应用于服务器端运行。 JavaScript 随着 Netscape 公司的战略而改变为 LiveScript，直到 1995 年 12 月 Netscape 公司与 SUN 公司才正式、公开地发布声明，LiveScript 语言更改为 JavaScript。 而 JavaScript 之所以改名，只是因为当时的 Java 语言很火而已。 ECMAScript 介绍 JavaScript 的核心语言是 ECMAScript，ECMAScript 是由 ECMA（欧洲计算机制造商协会）定义的标准化脚本语言，与 Web 浏览器没有依赖关系。ECMAScript 不仅可以运行在内建 JavaScript 引擎的浏览器中，也可以运行在独立的 JavaScript 解释器中（例如 Node.js）。 ECMAScript 规定了下列组成部分：语法、类型、语句、关键字、保留字、操作符及对象等。 JavaScript 实现了 ECMAScript，其他脚本语言同样实现了 ECMAScript（例如 Adobe 公司的 ActionScript 语言）。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 12:04:55 "},"chapter1/runtime-environment.html":{"url":"chapter1/runtime-environment.html","title":"第二节 运行环境","keywords":"","body":"JavaScript 语言目前比较主流的运行方式有两种。 一种是基于浏览器环境，这也是 JavaScript 最初也是最主流的一种运行方式。但由于目前网络环境越发复杂，可以内嵌浏览器的环境也越来越多。例如 PC 端浏览器、移动端浏览器、微信内置浏览器等。 一种是基于解释器环境，这种方式目前主要是以 Node.js 环境为主的。 基于浏览器 基于浏览器环境的这种方式，我们目前的测试是使用了浏览器自带的开发者工具实现的。这里我们主要测试 Chrome 浏览器和 Firefox 浏览器，当然其他浏览器也都提供了相关功能。 1. Chrome 浏览器 2. Firefox 浏览器 基于解释器 独立的 JavaScript 解释器是非浏览器环境运行 JavaScript 脚本代码的环境。目前最流行的 JavaScript 解释器为 Node.js，Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 第一个程序 下面，我们通过 Node.js 环境运行第一个 JavaScript 程序。当然，这个程序并没有什么实际意义，只是让你先感受一下 JavaScript 语言。 1. 点击程序 Node.js，运行 Node.js 命令行模式。 2. 输入以下代码，回车进行运行，并查看结果。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 11:34:41 "},"chapter1/code-debug.html":{"url":"chapter1/code-debug.html","title":"第三节 代码调试","keywords":"","body":"代码调试，是我们使用 JavaScript 语言编程过程中一项不可缺少的环节。虽然这并不是什么技术内容，但在实际开发中，依旧起着很重要的作用。 接下来，就让我们看一看基于 Node.js 环境的一些调试手段有哪些。 console 控制台 console 用于提供控制台标准输出，它是由 Microsoft 公司的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的标准，而独立 JavaScript 解释器 Node.js 也沿用了这个标准。 方法 描述 console.log() 向标准输出流打印字符并以换行符结束 console.info() 向标准输出流打印信息性消息。输出文字外，会显示一个蓝色的惊叹号 console.warn() 向标准输出流打印警告性消息。输出文字外，会显示一个黄色的惊叹号 console.error() 向标准输出流打印错误性消息。输出文字外，会显示一个红色的叉子 如下示例代码，可在浏览器的开发者工具或者 Node.js 环境中运行: // 用于输出日志性消息 console.log(\"这是一个log日志性消息.\"); // 用于输出信息性消息 console.info(\"这是一个info信息性消息.\"); // 用于输出警告性消息 console.warn(\"这是一个warn警告性消息.\"); // 用于输出错误性消息 console.error(\"这是一个error错误性消息.\"); Node.js 调试器 基于 Chrome V8 引擎的 Node.js 解释器提供了一个强大的调试器，帮助开发人员调试应用程序。 1. 在 JavaScript 代码中添加 debugger 语句，debugger 语句相当于在代码中标注一个断点。 var str = \"这是一个测试内容.\"; // 定义一个用于测试的变量 debugger; // 添加debugger语句 console.log(str); // 输出测试内容 2. 以 debug 方式运行 JavaScript 代码: node debug debugger.js node-inspector node-inspector 模块为在 Node.js 解释器中调试 JavaScript 代码提供了另一种选择，比 Node.js 内建的 debugger 强大很多。 1. 使用 npm 安装 node-inspector 模块: npm install -g node-inspector 2. 启动 inspector 服务，实现通过浏览器连接 node-spector: node-inspector 3. 以 debug 方式运行 JavaScript 代码: node --debug-brk 03_inspector.js 4. 使用 Chrome 浏览器通过以下地址进行调试代码: http://127.0.0.1:8080/?port=5858 注意: node-inspector 模块目前只能使用 Chrome 浏览器，其他浏览器无任何效果。 附录 node-inspector 安装失败问题解决 安装失败原因: node-inspector 模块是通过 npm 方式在线安装，而 npm 的镜像是在国外，由于国内的一些特殊情况可能会导致安装失败。 解决办法: 可以使用由淘宝提供的国内 npm 镜像进行替换，保证 node-inspector 模块安装成功。 淘宝 npm 使用 1. 在命令行中输入以下命令，安装淘宝 npm 定制的 cnpm: npm install -g cnpm --registry=https://registry.npm.taobao.org 2. 通过淘宝 npm 定制的 cnpm 安装模块: cnpm install [name] 注意: 通过 npm 或 cnpm 方式安装镜像只能在线安装，所以确保当前系统环境可以连接互联网。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 12:06:52 "},"chapter2/grammar.html":{"url":"chapter2/grammar.html","title":"第一节 语法入门","keywords":"","body":"本节课程，我们将学习 JavaScript 语言的基础语法。这些虽然都是最基本的内容，但可以帮助我们养成一个良好的编程习惯。 区分大小写 JavaScript 是一种区分大小写的语言。这意味着 JavaScript 的关键字、变量名、函数名、以及任何其他的标识符必须使用一致的大小写形式。比如 longestory、Longestory 或 LONGESTORY 是不同的变量名。 var longestory = \"longestory\";// 定义longestory变量 console.log(longestory);// 打印longestory变量 var Longestory = \"Longestory\";// 定义Longestory变量 console.log(Longestory);// 打印longestory变量 var LONGESTORY = \"LONGESTORY\";// 定义LONGESTORY变量 console.log(LONGESTORY);// 打印LONGESTORY变量 注意: 在 JavaScript 中定义变量名和函数名时应该特别注意。 空格和换行 JavaScript 会忽略出现在代码中的空格、制表符和换行符。 由于可以自由地在代码中使用空格、制表符和换行符，所以采用争气、一直的缩进来形成统一的编码风格，从而提高代码的可读性显得尤为重要。 JavaScript 还可以识别水平制表符、垂直制表符、换页符等，JavaScript 将以下字符识别为行结束符: 换行符、回车符、行分隔符、段分隔符等。回车符加换行符在一起被解析为一个单行结束符。 可选的分号 JavaScript 的语句一般是以一个分号作为结尾。当然，JavaScript 也允许忽略这个分号。如果省略分号，则由解释器确定语句的结尾， 如下述示例代码所示: var sum = a + b// 即使没有分号也是有效的语句 —— 不推荐 var diff = a - b;// 有效的语句 —— 推荐 注意: 在 JavaScript 中，虽然语句结尾的分号不是必需的，但还是建议任何时候都不要省略。使用分号是一个非常好的编程习惯。 注释 在编写 JavaScript 代码时，经常利用注释为代码添加说明。注释的内容会被 JavaScript 解释器/引擎忽略，JavaScript 支持两种格式的注释: 单行注释 // 这里是单行注释 多行注释 /* * 这里是多行注释 */ 注意: 上述注释的第二行是以星号开始，但这并不是必需的。 语句 JavaScript 代码将多行组合成一个代码块，每个代码块一般是以左花括号（{）开始，以右花括号（}）结束。 如下述示例代码所示: if(test){ test = false; alert(test); } 注意: 一般在执行多行代码时才需要语句块，但最好是始终都使用花括号将代码块进行包裹。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 12:14:44 "},"chapter2/keywords.html":{"url":"chapter2/keywords.html","title":"第二节 关键字与保留字","keywords":"","body":"JavaScript 语言的关键字和保留字，简单理解就是具有特殊含义的字符，你在定义变量、函数和对象名称时不能使用的。 注意: 随着 JavaScript 版本的更新，保留字可能会成为关键字。所以，这里所说的关键字和保留字是具有时效性的。 关键字 JavaScript 定义了一组具有特定用途的关键字，这些关键字可用于表示语句的开始或结束、或者执行特定操作等。也就是说，定义变量名或、函数名或对象名时不能使用这些名称。 保留字 JavaScript 除了定义了一组关键字，还定义了一组同样不能作为变量名、函数名或对象名的保留字。保留字可能在将来被作为新的关键字出现的。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 12:38:30 "},"chapter3/variable.html":{"url":"chapter3/variable.html","title":"第一节 变量","keywords":"","body":"什么是变量 变量是存储数据信息的容器。变量被认为是有名字的容器。在代码中，使用变量名为值命名，需要遵守一定的规则。 注意: 在 JavaScript 代码中，必须先声明一个变量，这个变量才能被使用。 JavaScript 中的变量是弱类型的，也称之为松散类型的。所谓弱类型/松散类型就是可以用来保存任何类型的数据。 如下示例代码，定义了一个变量 v，并重新赋值为 string: var v = 100; v = \"string\"; 上述代码只是展示了变量的用法，具体的使用我们将在下面的内容中学习。 变量的声明 在 JavaScript 代码中，使用变量前应当先声明。变量是使用关键字 var 声明的。 1. 只声明未初始化，变量的值自动取值为 undefined 一行代码只声明一个变量: var sum;// 值为undefined var msg;// 值为undefined 一行代码声明多个变量: var x, y, z;// 值为undefined 2. 将变量的声明和初始化合写在一起 一行代码只声明一个变量并赋值: var sum = 100;// 值为 100 var msg = \"this is message\";// 值为 this is message 一行代码声明多个变量并赋值: var x = 0, y = 1, z = 2; 注意: 等号（=）是赋值运算符。 命名规则 变量的命名需要遵守一定的规则的，具体规则如下: 必须以字母、数字、下划线（_）、美元符号（$）开始。 不能以数字开头。 不能使用关键字和保留字作为名称。 由于 JavaScript 是区分大小写的，大写字母与小写字母并不冲突。 名称最好有明确的含义。 可以采用“匈牙利命名法”、“下划线命名法”、“小驼峰命名法”或“大驼峰命名法” 之一，在开发团队内进行协调统一。 声明的问题 1. 重复的声明 使用 var 关键字重复声明变量是合法且无害的。但是如果重复声明并初始化的，这就表示重复声明并初始化。由于 JavaScript 变量只能存储一个数据，之前存储的数据会被覆盖。 var msg = \"this is message\";// 值为 this is message var msg = 100;// 值为 100 2. 遗漏的声明 直接读取一个没有声明的变量的值，JavaScript 会报错。 console.log(str);// str 变量并没有声明 上述代码运行结果为报错，具体报错信息如下图所示: 注意: 为一个没有声明的变量初始化，是合法的，但并不推荐这样使用。 变量的使用 对声明的变量既可以读取操作，也可以赋值操作。 1. 读取操作 var message;// 只声明未初始化 console.log(message);// 输出 undefined var msg = “this is message”;// 声明并初始化 console.log(msg);// 输出 this is message 2. 赋值操作 var message;// 只声明未初始化 message = \"this is message\";// 初始化操作 var msg = \"this is message\";// 值会被覆盖 msg = \"this is another message\";// 重新赋值 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 13:02:08 "},"chapter3/constant.html":{"url":"chapter3/constant.html","title":"第二节 常量","keywords":"","body":"什么是常量 常量就是一个只读（read-only）的变量。常量与变量类似，同样用于存储数据信息。只是常量的数据一旦被定义，便不能被修改。 注意: 常量名习惯使用全大写形式。 ECMAScript 5 新增了声明常量使用的关键字 const。 如果省略 const 关键字，JavaScript 会认为是一个变量。 常量的声明 在 ECMAScript 5 版本前，没有定义常量的语法。使用var关键字定义变量，人为规定值不改变，也可以是不严格的常量。 var MY_CONST = 10; 这种方式只是人为规定常量，并不是语法规定。所以，这种方式并不严谨！ 在 ECMAScript 5 版本后，提供了关键字 const 定义常量。 const MY_FAV = 100; 注意: 常量的声明，必须进行初始化操作，否则会报错误。 const FOO; // SyntaxError: missing = in const declaration 上述示例代码的运行结果为报错，具体的报错信息如下图所示: 常量的使用 常量一旦被声明并初始化，值并不能被改变。常量的使用只能进行读取操作: // 定义常量MY_FAV并赋值7 const MY_FAV = 7; // 在 Firefox 和 Chrome 这会失败但不会报错(在 Safari这个赋值会成功) MY_FAV = 20; console.log(MY_FAV); // 输出 7 const MY_FAV = 20; // 尝试重新声明会报错 var MY_FAV = 20;// MY_FAV 保留给上面的常量，这个操作会失败 console.log(MY_FAV);// MY_FAV 依旧为7 注意: 上述示例代码具有时效性，浏览器版本不同，结果可能不同。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 13:07:37 "},"chapter4/data-type.html":{"url":"chapter4/data-type.html","title":"第一节 什么是数据类型","keywords":"","body":"在 JavaScript 代码中，能够表示并操作值的类型称之为数据类型。 数据类型可分为可变类型和不可变类型。可变类型的值是可修改的，对象和数据就属于可变类型；不可变类型的值是不可修改的，数字、布尔值、null 和 undefined 都属于不可变类型。 字符串可以看成由字符组成的数组，可能被误认为是可变的。但在 JavaScript 中，字符串的值是不可变的。 数据类型分类 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 13:24:24 "},"chapter4/primitive-type.html":{"url":"chapter4/primitive-type.html","title":"第二节 原始类型","keywords":"","body":"原始类型，又称为原始值，是直接代表 JavaScript 语言实现的最底层的数据。 原始类型分别为 boolean 类型、number 类型和 string 类型三种。当然，有些资料将 undefined 和 null 也归为原始类型（这里表示为特殊类型）。 声明变量并初始化值为原始类型，一般称之为字面量方式定义变量，也可以称之为直接量方式定义变量。 boolean 类型 布尔（boolean）类型是指真或假、开或关、是或否。这个类型只有两个值：true 和 false。 注意: 由于 JavaScript 是区分大小写的，布尔类型的 true 和 false 全部是小写。 JavaScript 也可以将其他类型的数据，自动转换为布尔类型。 数据类型 转换为 true 值 转换为 false 值 boolean 类型 true false string 类型 任何非空字符串 “”（空字符串） number 类型 任何非零数字值（包括无穷大） 0 和 NaN object 类型 任何对象 null undefined undefined number 类型 number 类型是指数字，JavaScript 不区分整数类型和浮点类型。 整数类型: 包括负整数、0 和正整数等。 浮点类型: 表示小数，JavaScript 中的所有数字均用浮点类型表示。 进制，是指一种记数方式。 八进制: 以数字 0 开始，其后跟随一个由 0 ~ 7 之间的数字组成的序列。 十进制: 使用一个数字序列表示一个十进制整数。 十六进制: 由 0 ~ 9，A ~ F 组成，字母不区分大小写。 注意: 八进制或十六进制的数值最终会被转换成十进制数值。 浮点类型 浮点类型，就是指该数值包含整数部分、小数点和小数部分。 var floatNum1 = 0.1; var floatNum2 = .1;// 有效，但不推荐 注意: JavaScript 允许小数点前可以没有整数，但不推荐这种写法。 保存浮点类型需要的空间是保存整数类型的两倍。 如果小数点后面没有任何数字，那这个数值作为整数类型保存。 var floatNum3 = 1.;// 小数点后面没有数字 —— 解析为 1 var floatNum4 = 10.0;// 整数 —— 解析为 10 四舍五入误差 整数有无数个，但 JavaScript 通过浮点类型只能表示有限的个数（确切地说是 18 437 736 874 454 810 627 个）。也就是说，当在 JavaScript 中使用浮点类型时，常常只是真实值的一个近似表示。如下示例代码所示: var x = .3 - .2; var y = .2 - .1; x == y;// 值为false，表示两值不相等 x == .1;// 值为false，.3-.2 不等于 .1 y = .1;// 值为true，.2-.1 等于 .1 注意: 建议使用大整数表示金额。例如使用分作为单位，而不是使用元作为单位。 NaN NaN（Not a Number），即非数值，是一个特殊的数值。任何涉及 NaN 的操作都会返回 NaN。NaN 与任何值都不相等，包括 NaN 本身。 针对上述特点，JavaScript 提供了 isNaN() 函数。该函数用于判断计算结果是否为数值。 console.log(isNaN(10));// 输出false（10是一个数值） console.log(isNaN(\"10\"));// 输出false（可以被转换成数值 10） console.log(isNaN(\"blue\"));// 输出true（不能转换成数值） console.log(isNaN(true));// 输出false（可以被转换成数值 1） string 类型 string 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，被称之为字符串。字符串可以由双引号（\"）或单引号（'）表示。 var firstString = \"Nicholas\"; var secondString = 'Zakas'; string 类型包含一些特殊的转义字符，用于表示非打印字符。 转义字符 含义 \\n 换行符 \\t 制表符 \\b 退格符 \\r 回车符 \\f 换页符 \\ 斜杠 \\' 单引号（'），在用单引号表示的字符串中使用 \\\" 双引号（\"），在用双引号表示的字符串中使用 typeof 运算符 由于 JavaScript 是弱类型/松散类型的，因此需要有一种手段来检测给定变量的数据类型。typeof 运算符就是负责提供这方面信息，如下述代码: var message = \"this is message\"; console.log(typeof message);// 输出 string console.log(typeof(message));// 输出 string 注意: typeof 运算符加上圆括号，会像是函数，而不是运算符，并不建议这种写法。 值 类型 true 或 false boolean 任意字符串 string 任意数字或 NaN number Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 13:39:04 "},"chapter4/wrapper-type.html":{"url":"chapter4/wrapper-type.html","title":"第三节 包装类型","keywords":"","body":"在 JavaScript 中，对应原始类型提供了包装类型。通过包装类型可以创建原始类型的对象（后面的课程学习）。 由于 JavaScript 是区分大小写的，从写法上来说，原始类型是全部小写，包装类型则是全部大写。 一般不建议使用包装类型定义对应的数据类型，但包装类型提供了操作相应值的方法。 说明: 包装类型涉及到对象的概念，具体技术内容会在后面的课程学习。 Boolean 类型 Boolean 类型是原始类型 boolean 类型对应的包装类型。 var bool = new Boolean(true); Boolean 类型与 boolean 类型的区别: typeof 运算符对原始类型返回 boolean，而对包装类型为 object。 instanceof 运算符测试 Boolean 类型返回 true，而测试 boolean 类型返回 false。 注意: 不建议使用 Boolean 类型。 Number 类型 Number 类型是原始类型 number 类型对应的包装类型。 var num = new Number(10); Number 类型与 number 类型的区别: typeof 运算符对原始类型返回 number，而对包装类型为 object。 instanceof 运算符测试 Number 类型返回 true，而测试 number 类型返回 false。 注意: 不建议使用 Number 类型。 String 类型 String 类型是原始类型 string 类型对应的包装类型。 var str = new String(\"hello world\"); String 类型与 string 类型的区别: typeof 运算符对原始类型返回 string，而对包装类型为 object。 instanceof 运算符测试 String 类型返回 true，而测试 string 类型返回 false。 注意: 不建议使用 String 类型。 instanceof 运算符 instanceof 运算符的左操作数是一个包装类型的变量，右操作数是对应的数据类型。如果左侧的变量是右侧的数据类型，则表达式返回 true；否则返回 false。 例如下述示例代码: var str = \"this is message\"; str instanceof String;// 计算结果为 true, str是String类型 str instanceof Object;// 计算结果为 true, 所有包装类型都是Object的实例 str instanceof Number;// 计算结果为 false 注意: 所有对象都是 Object 类型的实例对象，通过 instanceof 运算符判断一个对象是否为具体数据类型，也包含\"父类\"。（后面课程会学习） Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 19:38:57 "},"chapter4/special-type.html":{"url":"chapter4/special-type.html","title":"第四节 特殊类型","keywords":"","body":"undefined 和 null 值都是 JavaScript 中的特殊类型。在实际开发中，这两个特殊类型也是经常出现错误的地方。尤其是 null 值。 undefined JavaScript 中有两个表示空的数据类型，undefined 和 null，其中比较有用的是 undefined。 undefined 类型只有一个值，就是 undefined。 下列情况会返回 undefined: 访问未修改的变量 undefined。 没有定义 return 表达式的函数隐式返回 undefined。 return 表达式没有显式的返回任何内容。 访问不存在的属性。 任何被设置为 undefined 值的变量。 null null 值是 JavaScript 中的一个特殊类型，用于表示一个不再指向任何内存空间地址的变量。 null 值多用于释放 JavaScript 中的资源（变量、数组和函数等）。 注意: 使用 typeof 运算符计算 null 的话，返回的是 object。 var longestory = null; console.log(longestory);// 输出 null undefined 与 null undefined 与 null 的共同点是它们都是原始类型，保存在栈中。 而不同点是: undefined: 表示变量声明但未被赋值，是所有未赋值变量的默认值。一般很少主动使用。 null: 表示一个没有指向任何内存地址的变量，将来可能指向某个具体内存地址。一般用于主动释放资源。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 19:44:54 "},"chapter4/type-conversion.html":{"url":"chapter4/type-conversion.html","title":"第五节 类型转换","keywords":"","body":"数据类型转换，也是使用 JavaScript 语言编程进行遇到的操作，尤其是隐世类型转换。 隐式类型转换 由于 JavaScript 是弱类型/松散类型的，在任何情况下都可以强制转换。 1. 转换为字符串: 将一个值加上空字符串可以轻松转换为字符串类型。 '' + 10 === '10'; // true 2. 转换为数字: 使用一元的加号操作符，可以把字符串转换为数字。 +'10' === 10; // true 3. 转换为布尔值: 使用否操作符两次，可以把一个值转换为布尔型。 !!'foo'; // true 显式类型转换 1. 使用 JavaScript 的包装类型的构造函数进行类型转换。 构造函数 描述 Number() 将字符串或布尔值转换为数字，如果包含非法字符，则返回 NaN String() 将数字或布尔值转换为字符串 Boolean() 将字符串或数字转换为布尔值 2. 使用数据类型的转换函数进行类型转换。 构造函数 描述 toString() 将数字或布尔值转换为字符串 parseInt() 将字符串或布尔值转换为整数类型 parseFloat() 将字符串或布尔值转换为浮点类型 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 19:50:15 "},"chapter5/operator-summary.html":{"url":"chapter5/operator-summary.html","title":"第一节 什么是运算符","keywords":"","body":"JavaScript 提供了一组用于操作数据值的运算符。 算数运算符（+ - * / % ++ --） 比较运算符（> >= 逻辑运算符（&& || !） 赋值运算符（= += -= *= /= %= ） 字符串连接运算符（+） 条件运算符（? :） 特殊运算符（typeof instanceof delete） Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 19:54:34 "},"chapter5/arithmetic-operator.html":{"url":"chapter5/arithmetic-operator.html","title":"第二节 算数运算符","keywords":"","body":"算数运算符 给定 A=20 B=10 条件，下述表格描述算数运算符: 运算符 描述 例子 + 两个运算数相加 A + B == 30 - 第一个运算数减去第二个运算数 A – B == 10 * 两个运算数相乘 A * B == 200 / 第一个运算数除以第二个运算数 A / B == 2 % 求余运算符，计算整除后的余数 A % B == 0 ++ 增量运算符，整数值逐次加 1 A++ == 21 -- 减量运算符，整数值逐次减 1 A-- == 19 算数运算符的基本操作比较简单，但下述情况需要特别注意: 如果运算数中的一个或两个是字符串类型，JavaScript 会自动转换为数字值，再进行计算。 如果运算数中的一个或两个是字符串类型，但其中的字符不是数字，JavaScript 会自动转换数字值失败，得到 NaN 结果。 任何一个运算数是 NaN，结果都是 NaN。 布尔值 false 和 true 会转换为 0 和 1 进行计算。 求余运算符 求余运算符，用于计算两个运算数整除后的余数。 console.log( 10 % 3 );// 输出 1 console.log( -10 % 3 );// 输出 -1 console.log( 10 % -3 );// 输出 1 console.log( -10 % -3 );// 输出 -1 自增运算符 自增运算符，用于整数值逐次加 1。分别具有两种用法: 前置型: 自增运算符位于运算数之前。先加 1，再赋值。 后置型: 自增运算符位于运算数之后。先赋值，再加 1。 var x = 3; console.log( x++ );// 输出 3 console.log( x );// 输出 4 var y = 3; console.log( ++y );// 输出 4 console.log( y );// 输出 4 自减运算符 自减运算符，用于整数值逐次减 1。分别具有两种用法: 前置型: 自增运算符位于运算数之前。先减 1，再赋值。 后置型: 自增运算符位于运算数之后。先赋值，再减 1。 var x = 3; console.log( x-- );// 输出 3 console.log( x );// 输出 2 var y = 3; console.log( --y );// 输出 2 console.log( y );// 输出 2 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 20:02:06 "},"chapter5/comparison-operator.html":{"url":"chapter5/comparison-operator.html","title":"第三节 比较运算符","keywords":"","body":"比较运算符 给定 A=20 B=10 条件，下述表格描述比较运算符: 运算符 描述 例子 == 检查两个运算数的值是否相等，如果相等则结果为 true A == B 为 false != 检查两个运算数的值是否不等，如果不等则结果为 true A != B 为 true > 检查左边运算数是否大于右边运算数，如果是则结果为 true A > B 为 true >= 检查左边运算数是否大于或等于右边运算数，如果是则结果为 true A >= B 为 true 检查左边运算数是否小于右边运算数，如果是则结果为 true A 检查左边运算数是否小于或等于右边运算数，如果是则结果为 true A 全等与不全等 运算符 描述 === 两个运算数的值相等并且类型相同时，结果为 true !== 两个运算数的值不等或者类型不同时，结果为 true var x = 10; var y = '10'; console.log( x == y );// 输出 true console.log( x === y );// 输出 false console.log( x != y );// 输出 false console.log( x !== y );// 输出 true isNaN() 函数 isNaN() 函数用于判断其参数是否为 NaN（非数字值）。多用于检测使用类型转换函数进行数据类型转换后的结果是否为合法的数字值。 注意: NaN 与任何值（包括自身）进行比较，结果都是 false。不能使用 == 或者 === 运算符判断某个值是否是 NaN，而只能使用 isNaN() 函数。 console.log(isNaN(parseInt('123.45a')));// 输出 true console.log(isNaN('123.45a'));// 输出 true console.log(isNaN(Number('123.45a')));// 输出 true Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 20:56:10 "},"chapter5/logical-operator.html":{"url":"chapter5/logical-operator.html","title":"第四节 逻辑运算符","keywords":"","body":"逻辑运算符 给定 A=20 B=10 条件，下述表格描述比较运算符: 运算符 描述 例子 && 逻辑与运算符。如果两个运算数都是 true，则返回 true A && B 为 true ` ` 逻辑或运算符。如果两个运算数中任何一个是 true，则返回 true A ` ` B 为 true ! 逻辑非运算符。用于改变运算数的逻辑状态。如果逻辑状态为 true，则通过逻辑非运算符是逻辑状态改为 false !(A && B) 为 false 逻辑与运算符 B1 B2 结果 false false false false true false true false false true true true console.log( false && true );// 输出 false console.log( true && true );// 输出 true // 数字值 1 和 0 转换为布尔值 true 和 false console.log( 1 && 0 );// 输出 false // 空字符串转换为布尔值 false，非空字符串转换为布尔值 true console.log( \"\" && \"longestory\" );// 输出 false 逻辑或运算符 B1 B2 结果 false false false false true true true false true true true true console.log( false || true );// 输出 true console.log( false || false );// 输出 false // 数字值 1 和 0 转换为布尔值 true 和 false console.log( 1 || 0 );// 输出 true // 空字符串转换为布尔值 false，非空字符串转换为布尔值 true console.log( \"\" || \"longestory\" );// 输出 true 逻辑非运算符 B1 !B1 false true true false console.log( !true );// 输出 false console.log( !1 );// 输出 false console.log( !\"longestory\" );// 输出 false 注意: 能被转换为 false 的值有 null、0、NaN、空字符串(\"\") 和 undefined。 逻辑短路原则 所谓短路原则，就是只要确定运算符前面的运算数为 true 或 false，就可以确定返回结果为 true 或 false。 1. 逻辑与运算符 逻辑与运算符前面为 false，结果都将返回逻辑与运算符前面的值。 逻辑与运算符前面为 true，结果都将返回逻辑与运算符后面的值。 2. 逻辑或运算符 逻辑或运算符前面为 false，结果都将返回逻辑或运算符后面的值。 逻辑或运算符前面为 true，结果都将返回逻辑或运算符前面的值。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 21:07:17 "},"chapter5/bitwise-operator.html":{"url":"chapter5/bitwise-operator.html","title":"第五节 按位运算符","keywords":"","body":" 运算符 描述 例子 左移运算符。它把第一个运算数的所有二进制位向左移动第二个运算数指定的位数，而新的二进制位补0。将一个数向左移动一个二进制位相当于将该数乘以2，向左移动两个二进制位相当于将该数乘以4，以此类推 2 >> 带符号右移运算符。它把第一个运算数的所有二进制位向右移动第二个运算数指定的位数。为了保持运算结果的符号不变，左边二进制位补0或1取决于原参数的符号位。如果第一个运算数是正的，运算结果最高位补0；如果第一个运算数是负的，运算结果最高位补1。将一个数向右移动一位相当于将该数乘以2，向右移动两位相当于将该数乘以4，以此类推 2 >> 1 = 1 >>> 无符号右移运算符。这个运算符与>>运算符相像，除了位移后左边总是补0 2 >>> 1 = 1 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 21:11:55 "},"chapter5/assign-operator.html":{"url":"chapter5/assign-operator.html","title":"第六节 赋值运算符","keywords":"","body":"赋值运算符 赋值运算符用于为变量或属性进行赋值操作。 var longestory = \"longestory\";// 将字符串 \"longestory\" 赋值给变量 longestory var obj.x = 1;// 将数字值 1 赋值给 obj 对象的 x 属性 赋值运算符就是将右边运算数的值赋给左边运算数。 C = A + B;// 将A+B的值赋给C 赋值扩展运算符 运算符 描述 例子 += 加等赋值运算符，将右边运算符与左边运算符相加并将运算结果赋给左边运算数 C += A 相当于 C = C + A -= 减等赋值运算符，将左边运算数减去右边运算数并将运算结果赋给左边运算数 C -= A 相当于C = C - A *= 乘等赋值运算符，将右边运算数乘以左边运算数并将运算结果赋给左边运算数 C = A 相当于C = C A /= 除等赋值运算符， 将左边运算数除以右边运算数并将运算结果赋值给左边运算数 C /= A 相当于 C = C / A %= 模等赋值运算符，用两个运算数做取模运算并将运算结果赋值给左边运算数 C %= A 相当于 C = C % A 注意: C += A 由于运行时可以进行优化，执行效率都要优于C = C + A。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 11:38:43 "},"chapter5/string-concatenation-operator.html":{"url":"chapter5/string-concatenation-operator.html","title":"第七节 字符串连接运算符","keywords":"","body":"字符串连接运算符使用的是加法运算符（+）。 两个运算数都是数字值时，\"+\" 用于两个运算数相加计算。 两个运算数中的一个是字符串时，\"+\" 用于字符串连接计算。 var num1 = 1; var num2 = 2; var num3 = num1 + num2; // 加法计算 var num4 = \"4\"; var num5 = num1 + num4; //字符串拼接计算 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 11:39:29 "},"chapter5/conditional-operator.html":{"url":"chapter5/conditional-operator.html","title":"第八节 条件运算符","keywords":"","body":"条件运算符 条件运算符，首先判断一个表达式是真或假，然后根据判断结果执行两个给定指令中的一个。 运算符 描述 说明 ? : 条件表达式 如果条件为真 ? X值 : Y值 var age = 20; var msg = age > 18 ? \"成年人\" : \"未成年人\"; 条件运算符嵌套 条件运算符中，每个表达式可以又是一个条件运算表达式，称为条件运算的嵌套。 var score = 85; var result = score >= 80 ? \"优秀\" : ( score >= 60 ? \"合格\" ：\"不合格\" ); 上述代码的执行顺序如下: 执行 score >= 60 ? \"合格\" ：\"不合格\" 条件运算符 根据上一行的计算结果，再执行 score >= 80 ? \"优秀\" : 条件运算符 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 11:41:37 "},"chapter6/statement-summary.html":{"url":"chapter6/statement-summary.html","title":"第一节 什么是语句","keywords":"","body":"在 JavaScript 中，语句使用分号（;）进行分隔。可以在每行编写一条语句，也可以在每行编写多条语句。 语句可以被分为以下几种: 条件语句：JavaScript 解释器根据一个值判断是执行还是跳过指定语句。 循环语句：JavaScript 解释器根据一个值判断是否重复执行指定语句。 跳转语句：使 JavaScript 解释器跳转到指定语句。 注意: 建议每行编写一条语句，便于提高代码的阅读性。 JavaScript 解释器按照语句的编写顺序依次执行。 语句块 JavaScript 中使用一对花括号（{}）表示一个语句块。使用语句块为语句进行分组，这样使语句的结构清晰明了。 如下示例代码所示: { var longestory = \"www.longestory.com\"; console.log(longestory); } 注意: 语句块的结尾不需要分号。 语句块中的行都有缩进，但并不是必需的。 语句中声明变量是全局变量（后面的课程学习）。 空语句 空语句允许包含 0 条语句，JavaScript 解释器执行空语句时，不会执行任何动作。 空语句如下述示例代码所示: ; 注意: 如果有特殊目的使用空语句时，最好在代码中添加注释。这样可以更好地说明这条空语句是有用的。 流程控制语句 JavaScript 解释器按照语句的编写顺序依次执行，但也可以编写一些复杂的语句块，基本分为下述三种: Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 11:53:08 "},"chapter6/conditional-statement.html":{"url":"chapter6/conditional-statement.html","title":"第二节 条件语句","keywords":"","body":"条件语句就是指通过判断指定的计算结果，来决定是执行还是跳过指定的语句块。 如果说 JavaScript 解释器是按照代码的“路径”执行的话，那条件语句就是这条路径上的分叉点，代码执行到这里时必须选择其中一条路径继续执行。 JavaScript 提供了两种条件语句: if else 语句和 switch case 语句。 if 语句 if 语句是条件判断语句，也是最基本的流程控制语句。 我们可以通过如下示例代码，学习 if 语句的使用: var num = 5; if( num 注意: if 关键字后面的小括号不能被省略。 if 关键字后面的条件判断的结果必须是布尔值。如果结果为非布尔值的话，JavaScript 会自动转换为布尔值。 if 语句中的大括号（{}）可以被省略，但建议编写，以提高代码阅读性。 if else 语句 if else 语句是条件判断语句，但与 if 语句的执行流程并不相同。 我们可以通过如下示例代码，学习 if else 语句的使用: var score = 68; if( score 注意: if else 语句中的大括号（{}）可以被省略，但建议编写，以提高代码阅读性。 if else 语句嵌套 if else 语句支持嵌套写法，也就是说，可以在 if 或 else 后面的语句块中继续编写 if else 语句。 如下述示例代码所示: var score = 68; if( score > 90 ){ console.log(\"优秀\"); }else{ if( score >= 80 ){ console.log(\"良好\"); }else{ console.log(\"一般\"); } } else if 语句 else if 语句是在 if 语句的基础上，允许提供多个条件判断。 else if 语句实际上就是简化了的 if else 语句的嵌套写法。如下述代码: switch case 语句 switch case 语句是开关语句，但整体执行流程要比 if else 语句复杂的多。具体参考下述流程图: var num = 2; switch( num ){ case 1: console.log(\"查询余额\"); break; case 2: console.log(\"在线充值\"); break; default: console.log(\"转人工服务\"); } 注意: 在实际开发中，switch case 语句与 break 语句同时使用。 switch case 语句相对于 if else 语句执行性能更优，但也有很多需要注意的地方。 注意: switch 关键字后面的小括号、case 关键字后面的冒号都不能被省略的。 break 语句是跳出语句，一旦被执行，表示后面所有的 case 和 default 语句都不会被执行。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 12:05:21 "},"chapter6/loop-conditional.html":{"url":"chapter6/loop-conditional.html","title":"第三节 循环语句","keywords":"","body":"循环语句是一系列反复执行到复合特定条件的语句。为了更好地理解循环语句，可以将 JavaScript 代码想象成一条条的分支路径。循环语句就是代码路径中的一个回路，可以让一段代码重复执行。 while 语句 while 语句是一个基本循环语句，语法结构与 if 语句很类似。 var num = 0; while( num 注意: while 关键字后面的小括号不能被省略。 while 关键字后面的条件判断的结果必须是布尔值。如果结果为非布尔值的话，JavaScript 会自动转换为布尔值。 while 语句中的大括号（{}）可以被省略，但建议编写，以提高代码阅读性。 do while 语句 do while 语句也是一个基本循环语句，执行流程与 while 语句很类似。 var num = 0; do{ console.log( num ); num = num + 1; }while( num 注意: while 关键字后面的小括号不能被省略。 while 关键字后面的条件判断的结果必须是布尔值。如果结果为非布尔值的话，JavaScript 会自动转换为布尔值。 while 语句中的大括号（{}）可以被省略，但建议编写，以提高代码阅读性。 do while 与 while 语句的区别 do while 语句与 while 语句的差别极小: do while 语句: 先执行，再判断。 while 语句: 先判断，再执行。 当 while 关键字后面的条件第一次被执行的时候，如果返回结果是 false 的话: while 语句的语句块一次都不会被执行；而 do while 语句的语句块至少被执行一次。 for 语句 for 语句是一种最简洁的循环语句，其中包含三个重要部分: 初始化表达式: 初始化一个计数器，在循环开始前计算初始状态。 条件判断表达式: 判断给定的状态是否为 true。如果条件为 true，则执行语句块，否则跳出循环。 循环操作表达式: 改变循环条件，修改计数器的值。 for 语句的语法如下: if( 初始化表达式; 条件判断表达式; 循环操作表达式 ){ 语句块 } for 语句的特殊用法 for 语句的三个表达式都是允许为空的。 1. 初始化表达式为空的情况 初始化表达式 if( ; 条件判断表达式; 循环操作表达式 ){ 语句块 } 2. 循环操作表达式为空的情况 if(初始化表达式; 条件判断表达式; ){ 语句块 循环操作表达式 } 循环嵌套 循环嵌套就是在一个循环语句中包含另一个循环语句。 for( var i = 1; i 注意: JavaScript 中对循环嵌套的层级没有任何限制。但一般建议循环嵌套三层，不然执行的性能会下降。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 12:23:23 "},"chapter6/goto-conditional.html":{"url":"chapter6/goto-conditional.html","title":"第四节 跳转语句","keywords":"","body":"JavaScript 中另一种语句就是跳转语句。从名称就可以看出，它使得 JavaScript 代码的执行可以从一个位置到另一个位置。 跳转语句提供了 break 和 continue 两种，用于跳转当前的循环或开始下一次的循环等。 break 语句 break 语句是中断语句，用于终止循环语句或开关语句。 1. 终止循环语句，例如 while、do while 以及 for 语句等 for( var i = 0; i 2. 终止开关语句（switch case） continue 语句 continue 语句是连续语句，用于重新开始 while、do while 和 for 语句。 for( var i = 0; i 上述代码的执行结果为 1 2 3 4 6 7 8 9。当 i 等于 5 时，结束本次循环，开始下一次的循环执行。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 12:25:45 "},"chapter7/array-summary.html":{"url":"chapter7/array-summary.html","title":"第一节 什么是数组","keywords":"","body":"数组是值的有序集合。数组中的每个值叫做一个元素，而每个元素在数组中都有一个唯一的位置。这个位置用数字表示，叫做索引数据；用字符串表示，叫做关联数组。 JavaScript 数组是无类型的: 数组的元素可以是任何类型，例如字符串、数字值、布尔值等，而且每个数组中的不同元素可能是不同类型。 JavaScript 数组是动态的: 根据需要，可以动态地向数组插入新的元素，或者从数组中删除指定的元素。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 13:55:11 "},"chapter7/one-dimensional-array.html":{"url":"chapter7/one-dimensional-array.html","title":"第二节 一维数组","keywords":"","body":"定义数组 数组的最大作用就是用于存储多个值。定义数组分别两种形式: 1. 使用数组字面量方式 var arr1 = []; var arr2 = [ 1, \"a\", true ]; 2. 使用数组关键字方式 var arr1 = Array(); var arr2 = Array( 1, \"a\", true ); 3. 使用构造函数方式 var arr1 = new Array(); var arr2 = new Array( 1, \"a\", true ); 注意: 在一个数组中的不同元素可以是不同数据类型。 索引数组 索引数组就是存储元素的位置使用数字值来表示，一般称之为下标或角标。具体创建方式如下述代码: var arr = []; arr[0] = 1; arr[1] = \"a\"; arr[2] = true; 注意: 索引数组的索引值是从 0 开始的。 关联数组 关联数组就是存储元素的位置使用字符串来表示，一般称之为名称（name或key）。具体创建方式如下述代码: var arr = []; arr['num'] = 1; arr['str'] = \"a\"; arr['bool'] = true; 注意: 关联数组的名称（name或key）是字符串，必需使用单引号或双引号将其包裹。 稀疏数组 稀疏数组就是包含 0 开始的不连续索引的数组。具体创建方式如下述代码: var arr = Array( 10 );// 数组没有任何元素，数组的长度为 10 var arr = [];// 创建一个空数组 arr[100] = \"a\";// 向下标为 100 的位置添加一个元素 a 注意: 上述代码中的第一行，并不是创建一个数组包含一个元素 10，而是创建一个不包含任何元素的数组长度为 10。 数组的长度 每个数组都有一个 length 属性，表示数组的长度。 1. 如果为非稀疏数组的话，length 属性的值表示当前数组包含元素的个数。 var arr1 = [ 1, \"a\", true ]; console.log( arr1.length );// 输出 3 2. 如果为稀疏数组的话，length 属性的值大于当前数组包含元素的个数。 var arr2 = []; arr2[14] = \"a\"; console.log( arr2.length );// 输出 15 数组元素的读取 数组的主要作用是用于存储和读取数据信息，之前已经对数组存储数据信息掌握了。下面来看看如何从数组中读取指定的元素: var arr = [ 1, \"a\", true]; console.log( arr[1] );// 输出字符串 a var arr = []; arr['num'] = 1; arr['str'] = \"a\"; arr['bool'] = true; console.log( arr['str'] );// 输出字符串 a 数组元素的修改 不仅可以从数组中读取指定的元素，还可以根据需求修改数组中指定的元素值。 var arr = [ 1, \"a\", true]; console.log( arr[1] );// 输出字符串 a arr[1] = \"b\"; console.log( arr[1] );// 输出字符串 b var arr = []; arr['num'] = 1; arr['str'] = \"a\"; console.log( arr['str'] );// 输出字符串 a arr['str'] = \"b\"; console.log( arr['str'] );// 输出字符串 b 数组元素的删除 不仅可以根据需求修改数组中指定的元素值，也可以删除数组中指定的元素值。数组删除指定元素值使用 delete 关键字。 var arr = [ 1, \"a\", true]; delete arr[1]; console.log( arr[1] );// 输出字符串 undefined 注意: 上述代码使用 delete 关键字执行删除数组元素值的操作时，并不影响数组的长度。 var arr = [ 1, \"a\", true]; delete arr[1]; console.log( arr.length );// 输出 3 遍历数组元素 使用 for 语句是遍历数组元素最常见的方法: var arr = [ 1, \"a\", true]; for( var i = 0; i 也可以从数组的最后向前（倒序）进行遍历: var arr = [ 1, \"a\", true]; for( var i = arr.length-1; i >= 0; i-- ){ console.log( arr[i] ); } for in 语句 在 ECMAScript 5 中新增了 for in 语句，同样也可以用于遍历数组: var arr = [ 1, \"a\", true]; for( var i in arr ){ console.log( i + \" : \" + arr[i] ); } 注意: for 关键字后定义的变量 i 表示当前数组的索引值。 for in 语句不仅会遍历数组的所有元素，还有一些数组自带的属性。一般建议使用 for 语句进行数组遍历。 for in 语句还可以用于遍历稀疏数组，循环的每次将一个有效元素返回。不存在的索引将不会遍历到: var arr = []; arr[100] = \"a\"; for( var i in arr ){ console.log( i + \" : \" + arr[i] ); } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 14:04:21 "},"chapter7/two-dimensional-array.html":{"url":"chapter7/two-dimensional-array.html","title":"第三节 二维数组","keywords":"","body":"数组是可以嵌套的，这就意味着一个数组可以作为一个元素被包含在另外一个数组里面。利用 JavaScript 这个特点，创建二维数组，即数组的数组。 定义二维数组 1. 定义一个规整的二维数组 var arr1 = [ [11,12,13], [21,22,23], [31,32,33] ]; 2. 定义一个不规整的二维数组 var arr2 = []; arr2[0] = [ 101 ]; arr2[1] = [ 201, 202 ]; arr2[2] = [ 301, 302, 303 ]; 使用二维数组 读取二维数组中的具体元素 var arr1 = [ [11,12,13], [21,22,23], [31,32,33] ] ; console.log( arr1[0][0] );// 值为11 arr1[1][2] = 230;// 把23更改为230 二维数组的遍历需要使用循环嵌套来实现 for( var i = 0; i Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 14:07:03 "},"chapter8/function-summary.html":{"url":"chapter8/function-summary.html","title":"第一节 什么是函数","keywords":"","body":"函数是这样的一段JavaScript代码，它只定义一次，但可能被执行或调用多次。 简单来说，函数就是一组可重用的代码，你可以在你程序的任何地方调用他。 例如下述代码: function fn(){ console.log(\"this is function\"); } Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 14:29:41 "},"chapter8/function.html":{"url":"chapter8/function.html","title":"第二节 函数","keywords":"","body":"函数定义 定义函数有两种方式: 1. 函数声明方式 function fn(){ console.log(\"this is function\"); } 2. 字面量表达式 var fun = fnction(){ console.log(\"this is function\"); } 函数调用 定义一个函数并不会自动的执行它。定义了函数仅仅是赋予函数以名称并明确函数被调用时该做些什么。调用函数才会真正执行这些动作。 例如下述代码: 定义一个函数fn function fn(){ console.log(\"this is function\"); } 调用函数 fn fn();// 输出字符串 this is function 函数参数 函数的参数就相当于在函数中使用的变量（虽然这个比方不是很准确）。JavaScript 中的函数定义并未制定函数参数的类型，函数调用时也未对传入的参数做任何的类型检查。 函数的参数可以分为以下两种: 形参: 出现在函数定义文法中的参数列表是函数的形式参数，简称形参。简单来说，就是定义函数时使用的参数就是形参。 实参: 函数调用时实际传入的参数是函数的实际参数，简称实参。简单来说，就是调用函数时使用的参数就是实参。 注意: 一般情况下，形参与实参的个数是相同的。但在 JavaScript 中并不强求这一点，在特殊情况下，函数的形参和实参的个数可以不相同。 function fn( one, two ){ console.log( one + two ); } fn( 1, 2 );// 输出 3 上述代码中，定义函数 fn 时，one 和 two 就是函数的形参；调用函数 fn 时，1 和 2 就是函数的实参。 return 语句 函数还可以包含一个返回语句（return）。当然，这并不是必需的。return 语句使函数可以作为一个值来使用。具体用法如下述代码: function fn( msg ){ return \"hello\" + msg; } // 变量 fun 的值为 hello longestory var fun = fn(\"longestory\"); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 14:46:14 "},"chapter8/predefined-function.html":{"url":"chapter8/predefined-function.html","title":"第三节 预定义函数","keywords":"","body":"预定义函数 JavaScript 预定义了一组函数，又称为全局函数，允许直接使用。 函数 描述 eval() 对一串字符串形式的JavaScript代码字符求值 uneval() 创建的一个Object的源代码的字符串表示 isFinite() 判断传入的值是否是有限的数值 isNaN() 判断一个值是否不是数字值 parseInt() 解析字符串参数，并返回指定的整数 parseFloat() 解析字符串参数，并返回一个浮点数 decodeURI() 对已编码的统一资源标识符(URI)进行解码，并返回其非编码形式 encodeURI() 对统一资源标识符(URI)进行编码，并返回编码后的URI字符串 eval() 函数 eval() 函数用于执行以字符串（String）形式出现的 JavaScript 代码。此函数可以实现动态的执行 JavaScript 代码。具体用法如下述代码: // 定义一个字符串，内容为JavaScript代码 var js = \"console.log('this is javascript')\"; // 通过 eval()函数执行上述内容 eval(js);// 输出 this is javascript 字符编码与解码 encodeURI() 函数可把字符串作为 URI 进行编码。对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的: , / ? : @ & = + $ # decodeURI() 函数可对 encodeURI() 函数编码过的 URI 进行解码。 decodeURI() 函数和encodeURI() 函数的具体用法如下述代码: var uri = \"http://www.longestory.com/Web前端开发工程师\"; var encode = encodeURI( uri ); // 输出 http://www.longestory.com/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88 console.log( encode ); var decode = decodeURI( encode ); // 输出 http://www.longestory.com/Web前端开发工程师 console.log( decode ); 对以下在 URI 中具有特殊含义的 ASCII 标点符号，可以使用 encodeURIComponent() 函数和 decodeURIComponent() 函数。 var uri = \"http://www.longestory.com/font-end-developer\"; var encode = encodeURIComponent( uri ); // 输出 http%3A%2F%2Fwww.longestory.com%2Ffont-end-developer console.log( encode ); var decode = decodeURIComponent( encode ); // 输出 http://www.longestory.com/font-end-developer console.log( decode ); Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-13 14:52:03 "},"chapter9/scope-summary.html":{"url":"chapter9/scope-summary.html","title":"第一节 什么是作用域","keywords":"","body":"变量和函数都具有作用域。作用域就是变量和函数的可被访问的范围，控制着变量和函数的可见性和生命周期。 变量的作用域可被分为全局作用域和函数作用域（局部作用域）。如果变量是被定义在全局作用域的话，在 JavaScript 代码中的任何位置都可以访问该变量；如果变量是被定义在指定函数内部的话，在 JavaScript 代码中只能在该函数内访问该变量。 函数的作用域也可被分为全局作用域和函数作用域（局部作用域）。被定义在指定函数内部的函数被称之为局部函数或内部函数。 注意: ECMAScript 6 之前的 JavaScript 没有语句块作用域。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-14 10:45:42 "},"chapter9/variable-scope.html":{"url":"chapter9/variable-scope.html","title":"第二节 变量作用域","keywords":"","body":"全局变量 在所有函数之外声明的变量，叫做全局变量，因为它可被当前文档中的其他代码所访问。具体内容如下述代码所示: var msg = \"this is message\";// 定义全局变量 msg // 在全局作用域访问变量 msg console.log( msg );// 输出 this is message function fn(){ // 在函数作用域访问变量 msg console.log( msg );// 输出 this is message } fn(); 除了上述定义全局变量外，还有一种比较特殊的方式定义全局变量（具体用法如下述代码）。但这种特殊用法并不推荐！ function fun(){ // 定义变量时没有使用关键字 var longestory = \"this is longestory\"; // 在函数作用域访问变量 longestory console.log( longestory );// 输出 this is longestory } fun(); // 在全局作用域访问变量 longestory console.log( longestory );// 输出 this is longestory 局部变量 在函数内部声明的变量，叫做局部变量，因为它只能在该函数内部访问。具体用法如下述代码所示: function fun(){ // 定义局部变量 longestory var longestory = \"this is longestory\"; // 在函数作用域访问变量 longestory console.log( longestory );// 输出 this is longestory } fun(); // 在全局作用域访问变量 longestory console.log( longestory );// 输出报错 声明提前 JavaScript 变量的另一特别之处是，你可以引用稍后声明的变量，而不会引发异常。这一概念称为变量声明提升。 JavaScript 变量感觉上是被“举起”或提升到了所有函数和语句之前。然而提升后的变量将返回 undefined 值，所以即使在使用或引用某个变量之后存在声明和初始化操作，仍将得到 undefined 值。 全局变量声明提前 console.log( msg );// 不会报错，输出 undefined var msg = \"this is message\";// 定义全局变量 msg console.log( msg );// 输出 this is message 上述代码中的第一行输出不会报错，而是输出 undefined值。效果等同于如下述代码: var msg;// 定义全局变量 msg，但未初始化 console.log( msg );// 不会报错，输出 undefined msg = \"this is message\";// 初始化全局变量 msg console.log( msg );// 输出 this is message 局部变量声明提前 function fn(){ console.log( msg );// 不会报错，输出 undefined var msg = \"this is message\";// 定义全局变量 msg console.log( msg );// 输出 this is message } fn(); console.log( msg );// 输出报错 效果等同于如下述代码: function fn(){ var msg;// 定义局部变量 msg，但未初始化 console.log( msg );// 不会报错，输出 undefined msg = \"this is message\";// 定义全局变量 msg console.log( msg );// 输出 this is message } 按值传递 按值传递就是指将实参变量的值复制一份副本给函数的形参变量。JavaScript 中为函数传递参数时，都是按值传递的。 如果向函数传递的参数是原始类型数据，则在函数中修改参数变量的值，不会影响外部实参的变量。 var n = 100;// 全局变量n function fun( n ){// 参数变量也是局部变量 n -= 3;// 修改的是局部变量n console.log( n );// 输出的是局部变量n } fun( n );// 按值传递，方法内输出 97 console.log( n );// 输出全局变量的值 100 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-14 10:50:17 "},"chapter9/function-scope.html":{"url":"chapter9/function-scope.html","title":"第三节 函数作用域","keywords":"","body":"全局函数 函数与变量类似，具有全局作用域和函数作用域（局部作用域）。与全局变量类似，全局函数是被定义在全局作用域的，在任何位置都可以访问或调用该函数。 function fn( num1, num2){ console.log( num1 + num2 );// 输出 3 } fn( 1, 2 ); 内部函数 一个函数被定义在另一个函数内部，被称之为局部函数或内部函数。与变量类似，局部函数只能在当前函数的内部访问，而不能在全局作用域中被访问。 function outer(){// 全局函数 function inner(){// 局部函数 console.log(\"inner\"); } inner();// 调用正常 } inner();// 输出报错 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-14 10:51:13 "},"chapter10/object-summary.html":{"url":"chapter10/object-summary.html","title":"第一节 什么是对象","keywords":"","body":"第一节 什么是对象 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter10/object-object.html":{"url":"chapter10/object-object.html","title":"第二节 Object 对象","keywords":"","body":"第二节 Object 对象 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter10/create-object.html":{"url":"chapter10/create-object.html","title":"第三节 创建对象","keywords":"","body":"第三节 创建对象 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter10/attribute-of-object.html":{"url":"chapter10/attribute-of-object.html","title":"第四节 对象的属性","keywords":"","body":"第四节 对象的属性 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter10/function-of-object.html":{"url":"chapter10/function-of-object.html","title":"第五节 对象的方法","keywords":"","body":"第五节 对象的方法 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "}}