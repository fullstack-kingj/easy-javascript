{"./":{"url":"./","title":"前言","keywords":"","body":" 在线阅读 前言 本套课程共分为 10 个章节，从基础的概念到具体的用法，一一详细的进行阐述。只为努力作为学习 JavaScript 技术的最好的自学基础课程。 本套课程会一直更新，直到达到适合于所有人自学为止。 10 个章节内容，大体上可以被分为以下几个部分内容: 说明: 如果你已经掌握 JavaScript 中的部分内容，可以根据自己的情况选择性的进行学习。 第一部分: 概念 我们首先从第一章节概念入手，先掌握什么是 JavaScript、JavaScript 的运行环境以及如何进行代码调试。 这部分内容，是你学习 JavaScript 中后续内容的基础。概念清晰了，操作才会更顺手。学习概念，不仅仅只是单纯地阅读文字这么简单。要试着用自己的话来描述你所学习的概念，并把它发布到网络上，让别人替你检查，你的理解是否准确。 如果你不知道如何发布到网络上，可以加入底部的 QQ 讨论群，与其他人共同学习。 第二部分: 基础语法 从第二章到第五章，我们要掌握有关 JavaScript 的一些基础语法。这部分内容包含了一些最基本的语法内容、变量与常量、数据类型和运算符。 不要小瞧 JavaScript 的基础语法内容，这部分内容是我们学习使用 JavaScript 编程的根本。很多读者在学习这部分内容的时候，经常会忽略一些细节。这些往往都是将来我们使用 JavaScript 编程所遇到的错误。 这部分内容，作者会不断地更新补充。尽量做到面面俱到，让你在学习之后可以全面地掌握 JavaScript 的基础语法内容。 你可以 star 或者 watch 本课程，这样一旦有更新，GitHub 会通知你。 第三部分: 核心语法 这部分内容是从第六章到第十章，我们要掌握有关 JavaScript 的核心语法内容。这部分内容包含了语句、数组、函数、作用域以及对象。 学习这部分内容，需要读者既要理解概念，又要消化原理流程，还要动手进行操作。所以，这部分内容应该是本套课程最核心的部分，也是最难掌握的部分。 不过，不要灰心! 作者会在后续的更新中，加入大量适当的案例，帮助你更好地掌握这部分内容。 你可以 star 或者 watch 本课程，这样一旦有更新，GitHub 会通知你。 反馈 本套课程会尽量完善，编写过程中难免出现纰漏。你可以通过以下展示方式进行反馈，作者会根据反馈及时更新和修改。 交流 你可以扫描下方的二维码，加入本套课程的 QQ 讨论群，与其他童鞋一起学习交流。 版权 本套课程的文本内容免费开源，任何人都可以免费学习、分享，甚至可以进行修改。但需要注明作者及来源，并且不能用于商业。 本套课程采用知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议进行许可。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:48:18 "},"chapter1/javascript-summary.html":{"url":"chapter1/javascript-summary.html","title":"第一节 JavaScript 介绍","keywords":"","body":"JavaScript 是一门跨平台、面向对象的轻量级脚本语言，运行于 JavaScript 解释器/引擎。 JavaScript 内置了一个包含一系列对象的标准库，比如数组、日期、数学和一个语言元素集合包括操作符、流程控制及语句等内容。 JavaScript 解释器是作为 JavaScript 脚本代码的运行环境，如下述两种呈现方式: 独立安装的JavaScript解释器。 嵌入在浏览器内核中的JavaScript解释器。 JavaScript 简史 1992 年，Nombas 公司为自己的 CEnvi 软件开发了一款脚本语言 ScriptEase，可以嵌入在网页中。 1995 年， Netscape 公司为自己的 Navigator2.0 浏览器开发了另一种客户端脚本语言 Livescript，为了搭上当时很热 Java 的顺风车，临时把 LiveScript 改名为 JavaScript。 1996 年，Microsoft 公司在 IE3 中加入了 JScript（为避开 JavaScript 的版权问题）。 1997 年，JavaScript 1.1 作为草案提交给 ECMA（欧洲计算机制造商协会），完成了 ECMA-262 —— 定义了名为 ECMAScript 的脚本语言标准。 JavaScript 实现 虽然 JavaScript 与 ECMAScript 经常被认为是相同含义，但 JavaScript 的含义要比 ECMAScript 多。一个完整的 JavaScript 实现应该由下列三个不同的部分组成: 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM） JavaScript 应用 客户端 JavaScript 通过提供控制浏览器及其文档对象模型（DOM）的对象来扩展语言核心。例如: 客户端版本直接支持应用将元素放在 HTML 表单中并且支持响应用户事件，比如鼠标点击、表单提交和页面导航。 服务器端 JavaScript 通过提供有关在服务器上运行 JavaScript 的对象来可扩展语言核心。例如: 服务端版本直接支持应用和数据库通信，提供应用不同调用间的信息连续性，或者在服务器上执行文件操作。 与 JScript 的关系 JScript 是 Microsoft 公司为 IE3 浏览器添加的脚本语言，也是 JavaScript 的另一种实现，只是 Microsoft 公司为了避免与 Netscape 公司的 JavaScript 语言产生版权问题，而命名为 JScript。 至此，JavaScript 实现意味着存在两个不同的版本: Netscape 公司的 JavaScript 和 Microsoft 公司的 JScript，当时没有任何标准规定 JavaScript 的语法和特性，导致开发人员在使用 JavaScript 的时候需要考虑浏览器的兼容性问题。 直到以 JavaScript 1.1 为草案提交给 ECMA（欧洲计算机制造商协会）定义了 ECMA 标准，这个问题才得以缓解。 参考资料: MSDN 提供的 JavaScript 语言参考 与 Java 的关系 JavaScript 经常被误解为是 Java 的子集，实际上，这两种语言是完全不相干的。 JavaScript 与 Java 的语法很相似，就像 Java 和 C 语言的语法相似一样。JavaScript 最初被设计为运行在浏览器中的脚本语言，而 Java 是一种跨平台语言，目前主要应用于服务器端运行。 JavaScript 随着 Netscape 公司的战略而改变为 LiveScript，直到 1995 年 12 月 Netscape 公司与 SUN 公司才正式、公开地发布声明，LiveScript 语言更改为 JavaScript。 而 JavaScript 之所以改名，只是因为当时的 Java 语言很火而已。 ECMAScript 介绍 JavaScript 的核心语言是 ECMAScript，ECMAScript 是由 ECMA（欧洲计算机制造商协会）定义的标准化脚本语言，与 Web 浏览器没有依赖关系。ECMAScript 不仅可以运行在内建 JavaScript 引擎的浏览器中，也可以运行在独立的 JavaScript 解释器中（例如 Node.js）。 ECMAScript 规定了下列组成部分：语法、类型、语句、关键字、保留字、操作符及对象等。 JavaScript 实现了 ECMAScript，其他脚本语言同样实现了 ECMAScript（例如 Adobe 公司的 ActionScript 语言）。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 12:04:55 "},"chapter1/runtime-environment.html":{"url":"chapter1/runtime-environment.html","title":"第二节 运行环境","keywords":"","body":"JavaScript 语言目前比较主流的运行方式有两种。 一种是基于浏览器环境，这也是 JavaScript 最初也是最主流的一种运行方式。但由于目前网络环境越发复杂，可以内嵌浏览器的环境也越来越多。例如 PC 端浏览器、移动端浏览器、微信内置浏览器等。 一种是基于解释器环境，这种方式目前主要是以 Node.js 环境为主的。 基于浏览器 基于浏览器环境的这种方式，我们目前的测试是使用了浏览器自带的开发者工具实现的。这里我们主要测试 Chrome 浏览器和 Firefox 浏览器，当然其他浏览器也都提供了相关功能。 1. Chrome 浏览器 2. Firefox 浏览器 基于解释器 独立的 JavaScript 解释器是非浏览器环境运行 JavaScript 脚本代码的环境。目前最流行的 JavaScript 解释器为 Node.js，Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 第一个程序 下面，我们通过 Node.js 环境运行第一个 JavaScript 程序。当然，这个程序并没有什么实际意义，只是让你先感受一下 JavaScript 语言。 1. 点击程序 Node.js，运行 Node.js 命令行模式。 2. 输入以下代码，回车进行运行，并查看结果。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 11:34:41 "},"chapter1/code-debug.html":{"url":"chapter1/code-debug.html","title":"第三节 代码调试","keywords":"","body":"代码调试，是我们使用 JavaScript 语言编程过程中一项不可缺少的环节。虽然这并不是什么技术内容，但在实际开发中，依旧起着很重要的作用。 接下来，就让我们看一看基于 Node.js 环境的一些调试手段有哪些。 console 控制台 console 用于提供控制台标准输出，它是由 Microsoft 公司的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的标准，而独立 JavaScript 解释器 Node.js 也沿用了这个标准。 方法 描述 console.log() 向标准输出流打印字符并以换行符结束 console.info() 向标准输出流打印信息性消息。输出文字外，会显示一个蓝色的惊叹号 console.warn() 向标准输出流打印警告性消息。输出文字外，会显示一个黄色的惊叹号 console.error() 向标准输出流打印错误性消息。输出文字外，会显示一个红色的叉子 如下示例代码，可在浏览器的开发者工具或者 Node.js 环境中运行: // 用于输出日志性消息 console.log(\"这是一个log日志性消息.\"); // 用于输出信息性消息 console.info(\"这是一个info信息性消息.\"); // 用于输出警告性消息 console.warn(\"这是一个warn警告性消息.\"); // 用于输出错误性消息 console.error(\"这是一个error错误性消息.\"); Node.js 调试器 基于 Chrome V8 引擎的 Node.js 解释器提供了一个强大的调试器，帮助开发人员调试应用程序。 1. 在 JavaScript 代码中添加 debugger 语句，debugger 语句相当于在代码中标注一个断点。 var str = \"这是一个测试内容.\"; // 定义一个用于测试的变量 debugger; // 添加debugger语句 console.log(str); // 输出测试内容 2. 以 debug 方式运行 JavaScript 代码: node debug debugger.js node-inspector node-inspector 模块为在 Node.js 解释器中调试 JavaScript 代码提供了另一种选择，比 Node.js 内建的 debugger 强大很多。 1. 使用 npm 安装 node-inspector 模块: npm install -g node-inspector 2. 启动 inspector 服务，实现通过浏览器连接 node-spector: node-inspector 3. 以 debug 方式运行 JavaScript 代码: node --debug-brk 03_inspector.js 4. 使用 Chrome 浏览器通过以下地址进行调试代码: http://127.0.0.1:8080/?port=5858 注意: node-inspector 模块目前只能使用 Chrome 浏览器，其他浏览器无任何效果。 附录 node-inspector 安装失败问题解决 安装失败原因: node-inspector 模块是通过 npm 方式在线安装，而 npm 的镜像是在国外，由于国内的一些特殊情况可能会导致安装失败。 解决办法: 可以使用由淘宝提供的国内 npm 镜像进行替换，保证 node-inspector 模块安装成功。 淘宝 npm 使用 1. 在命令行中输入以下命令，安装淘宝 npm 定制的 cnpm: npm install -g cnpm --registry=https://registry.npm.taobao.org 2. 通过淘宝 npm 定制的 cnpm 安装模块: cnpm install [name] 注意: 通过 npm 或 cnpm 方式安装镜像只能在线安装，所以确保当前系统环境可以连接互联网。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 12:06:52 "},"chapter2/grammar.html":{"url":"chapter2/grammar.html","title":"第一节 语法入门","keywords":"","body":"本节课程，我们将学习 JavaScript 语言的基础语法。这些虽然都是最基本的内容，但可以帮助我们养成一个良好的编程习惯。 区分大小写 JavaScript 是一种区分大小写的语言。这意味着 JavaScript 的关键字、变量名、函数名、以及任何其他的标识符必须使用一致的大小写形式。比如 longestory、Longestory 或 LONGESTORY 是不同的变量名。 var longestory = \"longestory\";// 定义longestory变量 console.log(longestory);// 打印longestory变量 var Longestory = \"Longestory\";// 定义Longestory变量 console.log(Longestory);// 打印longestory变量 var LONGESTORY = \"LONGESTORY\";// 定义LONGESTORY变量 console.log(LONGESTORY);// 打印LONGESTORY变量 注意: 在 JavaScript 中定义变量名和函数名时应该特别注意。 空格和换行 JavaScript 会忽略出现在代码中的空格、制表符和换行符。 由于可以自由地在代码中使用空格、制表符和换行符，所以采用争气、一直的缩进来形成统一的编码风格，从而提高代码的可读性显得尤为重要。 JavaScript 还可以识别水平制表符、垂直制表符、换页符等，JavaScript 将以下字符识别为行结束符: 换行符、回车符、行分隔符、段分隔符等。回车符加换行符在一起被解析为一个单行结束符。 可选的分号 JavaScript 的语句一般是以一个分号作为结尾。当然，JavaScript 也允许忽略这个分号。如果省略分号，则由解释器确定语句的结尾， 如下述示例代码所示: var sum = a + b// 即使没有分号也是有效的语句 —— 不推荐 var diff = a - b;// 有效的语句 —— 推荐 注意: 在 JavaScript 中，虽然语句结尾的分号不是必需的，但还是建议任何时候都不要省略。使用分号是一个非常好的编程习惯。 注释 在编写 JavaScript 代码时，经常利用注释为代码添加说明。注释的内容会被 JavaScript 解释器/引擎忽略，JavaScript 支持两种格式的注释: 单行注释 // 这里是单行注释 多行注释 /* * 这里是多行注释 */ 注意: 上述注释的第二行是以星号开始，但这并不是必需的。 语句 JavaScript 代码将多行组合成一个代码块，每个代码块一般是以左花括号（{）开始，以右花括号（}）结束。 如下述示例代码所示: if(test){ test = false; alert(test); } 注意: 一般在执行多行代码时才需要语句块，但最好是始终都使用花括号将代码块进行包裹。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 12:14:44 "},"chapter2/keywords.html":{"url":"chapter2/keywords.html","title":"第二节 关键字与保留字","keywords":"","body":"JavaScript 语言的关键字和保留字，简单理解就是具有特殊含义的字符，你在定义变量、函数和对象名称时不能使用的。 注意: 随着 JavaScript 版本的更新，保留字可能会成为关键字。所以，这里所说的关键字和保留字是具有时效性的。 关键字 JavaScript 定义了一组具有特定用途的关键字，这些关键字可用于表示语句的开始或结束、或者执行特定操作等。也就是说，定义变量名或、函数名或对象名时不能使用这些名称。 保留字 JavaScript 除了定义了一组关键字，还定义了一组同样不能作为变量名、函数名或对象名的保留字。保留字可能在将来被作为新的关键字出现的。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 12:38:30 "},"chapter3/variable.html":{"url":"chapter3/variable.html","title":"第一节 变量","keywords":"","body":"什么是变量 变量是存储数据信息的容器。变量被认为是有名字的容器。在代码中，使用变量名为值命名，需要遵守一定的规则。 注意: 在 JavaScript 代码中，必须先声明一个变量，这个变量才能被使用。 JavaScript 中的变量是弱类型的，也称之为松散类型的。所谓弱类型/松散类型就是可以用来保存任何类型的数据。 如下示例代码，定义了一个变量 v，并重新赋值为 string: var v = 100; v = \"string\"; 上述代码只是展示了变量的用法，具体的使用我们将在下面的内容中学习。 变量的声明 在 JavaScript 代码中，使用变量前应当先声明。变量是使用关键字 var 声明的。 1. 只声明未初始化，变量的值自动取值为 undefined 一行代码只声明一个变量: var sum;// 值为undefined var msg;// 值为undefined 一行代码声明多个变量: var x, y, z;// 值为undefined 2. 将变量的声明和初始化合写在一起 一行代码只声明一个变量并赋值: var sum = 100;// 值为 100 var msg = \"this is message\";// 值为 this is message 一行代码声明多个变量并赋值: var x = 0, y = 1, z = 2; 注意: 等号（=）是赋值运算符。 命名规则 变量的命名需要遵守一定的规则的，具体规则如下: 必须以字母、数字、下划线（_）、美元符号（$）开始。 不能以数字开头。 不能使用关键字和保留字作为名称。 由于 JavaScript 是区分大小写的，大写字母与小写字母并不冲突。 名称最好有明确的含义。 可以采用“匈牙利命名法”、“下划线命名法”、“小驼峰命名法”或“大驼峰命名法” 之一，在开发团队内进行协调统一。 声明的问题 1. 重复的声明 使用 var 关键字重复声明变量是合法且无害的。但是如果重复声明并初始化的，这就表示重复声明并初始化。由于 JavaScript 变量只能存储一个数据，之前存储的数据会被覆盖。 var msg = \"this is message\";// 值为 this is message var msg = 100;// 值为 100 2. 遗漏的声明 直接读取一个没有声明的变量的值，JavaScript 会报错。 console.log(str);// str 变量并没有声明 上述代码运行结果为报错，具体报错信息如下图所示: 注意: 为一个没有声明的变量初始化，是合法的，但并不推荐这样使用。 变量的使用 对声明的变量既可以读取操作，也可以赋值操作。 1. 读取操作 var message;// 只声明未初始化 console.log(message);// 输出 undefined var msg = “this is message”;// 声明并初始化 console.log(msg);// 输出 this is message 2. 赋值操作 var message;// 只声明未初始化 message = \"this is message\";// 初始化操作 var msg = \"this is message\";// 值会被覆盖 msg = \"this is another message\";// 重新赋值 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 13:02:08 "},"chapter3/constant.html":{"url":"chapter3/constant.html","title":"第二节 常量","keywords":"","body":"什么是常量 常量就是一个只读（read-only）的变量。常量与变量类似，同样用于存储数据信息。只是常量的数据一旦被定义，便不能被修改。 注意: 常量名习惯使用全大写形式。 ECMAScript 5 新增了声明常量使用的关键字 const。 如果省略 const 关键字，JavaScript 会认为是一个变量。 常量的声明 在 ECMAScript 5 版本前，没有定义常量的语法。使用var关键字定义变量，人为规定值不改变，也可以是不严格的常量。 var MY_CONST = 10; 这种方式只是人为规定常量，并不是语法规定。所以，这种方式并不严谨！ 在 ECMAScript 5 版本后，提供了关键字 const 定义常量。 const MY_FAV = 100; 注意: 常量的声明，必须进行初始化操作，否则会报错误。 const FOO; // SyntaxError: missing = in const declaration 上述示例代码的运行结果为报错，具体的报错信息如下图所示: 常量的使用 常量一旦被声明并初始化，值并不能被改变。常量的使用只能进行读取操作: // 定义常量MY_FAV并赋值7 const MY_FAV = 7; // 在 Firefox 和 Chrome 这会失败但不会报错(在 Safari这个赋值会成功) MY_FAV = 20; console.log(MY_FAV); // 输出 7 const MY_FAV = 20; // 尝试重新声明会报错 var MY_FAV = 20;// MY_FAV 保留给上面的常量，这个操作会失败 console.log(MY_FAV);// MY_FAV 依旧为7 注意: 上述示例代码具有时效性，浏览器版本不同，结果可能不同。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 13:07:37 "},"chapter4/data-type.html":{"url":"chapter4/data-type.html","title":"第一节 什么是数据类型","keywords":"","body":"在 JavaScript 代码中，能够表示并操作值的类型称之为数据类型。 数据类型可分为可变类型和不可变类型。可变类型的值是可修改的，对象和数据就属于可变类型；不可变类型的值是不可修改的，数字、布尔值、null 和 undefined 都属于不可变类型。 字符串可以看成由字符组成的数组，可能被误认为是可变的。但在 JavaScript 中，字符串的值是不可变的。 数据类型分类 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 13:24:24 "},"chapter4/primitive-type.html":{"url":"chapter4/primitive-type.html","title":"第二节 原始类型","keywords":"","body":"原始类型，又称为原始值，是直接代表 JavaScript 语言实现的最底层的数据。 原始类型分别为 boolean 类型、number 类型和 string 类型三种。当然，有些资料将 undefined 和 null 也归为原始类型（这里表示为特殊类型）。 声明变量并初始化值为原始类型，一般称之为字面量方式定义变量，也可以称之为直接量方式定义变量。 boolean 类型 布尔（boolean）类型是指真或假、开或关、是或否。这个类型只有两个值：true 和 false。 注意: 由于 JavaScript 是区分大小写的，布尔类型的 true 和 false 全部是小写。 JavaScript 也可以将其他类型的数据，自动转换为布尔类型。 数据类型 转换为 true 值 转换为 false 值 boolean 类型 true false string 类型 任何非空字符串 “”（空字符串） number 类型 任何非零数字值（包括无穷大） 0 和 NaN object 类型 任何对象 null undefined undefined number 类型 number 类型是指数字，JavaScript 不区分整数类型和浮点类型。 整数类型: 包括负整数、0 和正整数等。 浮点类型: 表示小数，JavaScript 中的所有数字均用浮点类型表示。 进制，是指一种记数方式。 八进制: 以数字 0 开始，其后跟随一个由 0 ~ 7 之间的数字组成的序列。 十进制: 使用一个数字序列表示一个十进制整数。 十六进制: 由 0 ~ 9，A ~ F 组成，字母不区分大小写。 注意: 八进制或十六进制的数值最终会被转换成十进制数值。 浮点类型 浮点类型，就是指该数值包含整数部分、小数点和小数部分。 var floatNum1 = 0.1; var floatNum2 = .1;// 有效，但不推荐 注意: JavaScript 允许小数点前可以没有整数，但不推荐这种写法。 保存浮点类型需要的空间是保存整数类型的两倍。 如果小数点后面没有任何数字，那这个数值作为整数类型保存。 var floatNum3 = 1.;// 小数点后面没有数字 —— 解析为 1 var floatNum4 = 10.0;// 整数 —— 解析为 10 四舍五入误差 整数有无数个，但 JavaScript 通过浮点类型只能表示有限的个数（确切地说是 18 437 736 874 454 810 627 个）。也就是说，当在 JavaScript 中使用浮点类型时，常常只是真实值的一个近似表示。如下示例代码所示: var x = .3 - .2; var y = .2 - .1; x == y;// 值为false，表示两值不相等 x == .1;// 值为false，.3-.2 不等于 .1 y = .1;// 值为true，.2-.1 等于 .1 注意: 建议使用大整数表示金额。例如使用分作为单位，而不是使用元作为单位。 NaN NaN（Not a Number），即非数值，是一个特殊的数值。任何涉及 NaN 的操作都会返回 NaN。NaN 与任何值都不相等，包括 NaN 本身。 针对上述特点，JavaScript 提供了 isNaN() 函数。该函数用于判断计算结果是否为数值。 console.log(isNaN(10));// 输出false（10是一个数值） console.log(isNaN(\"10\"));// 输出false（可以被转换成数值 10） console.log(isNaN(\"blue\"));// 输出true（不能转换成数值） console.log(isNaN(true));// 输出false（可以被转换成数值 1） string 类型 string 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，被称之为字符串。字符串可以由双引号（\"）或单引号（'）表示。 var firstString = \"Nicholas\"; var secondString = 'Zakas'; string 类型包含一些特殊的转义字符，用于表示非打印字符。 转义字符 含义 \\n 换行符 \\t 制表符 \\b 退格符 \\r 回车符 \\f 换页符 \\ 斜杠 \\' 单引号（'），在用单引号表示的字符串中使用 \\\" 双引号（\"），在用双引号表示的字符串中使用 typeof 运算符 由于 JavaScript 是弱类型/松散类型的，因此需要有一种手段来检测给定变量的数据类型。typeof 运算符就是负责提供这方面信息，如下述代码: var message = \"this is message\"; console.log(typeof message);// 输出 string console.log(typeof(message));// 输出 string 注意: typeof 运算符加上圆括号，会像是函数，而不是运算符，并不建议这种写法。 值 类型 true 或 false boolean 任意字符串 string 任意数字或 NaN number Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 13:39:04 "},"chapter4/wrapper-type.html":{"url":"chapter4/wrapper-type.html","title":"第三节 包装类型","keywords":"","body":"在 JavaScript 中，对应原始类型提供了包装类型。通过包装类型可以创建原始类型的对象（后面的课程学习）。 由于 JavaScript 是区分大小写的，从写法上来说，原始类型是全部小写，包装类型则是全部大写。 一般不建议使用包装类型定义对应的数据类型，但包装类型提供了操作相应值的方法。 说明: 包装类型涉及到对象的概念，具体技术内容会在后面的课程学习。 Boolean 类型 Boolean 类型是原始类型 boolean 类型对应的包装类型。 var bool = new Boolean(true); Boolean 类型与 boolean 类型的区别: typeof 运算符对原始类型返回 boolean，而对包装类型为 object。 instanceof 运算符测试 Boolean 类型返回 true，而测试 boolean 类型返回 false。 注意: 不建议使用 Boolean 类型。 Number 类型 Number 类型是原始类型 number 类型对应的包装类型。 var num = new Number(10); Number 类型与 number 类型的区别: typeof 运算符对原始类型返回 number，而对包装类型为 object。 instanceof 运算符测试 Number 类型返回 true，而测试 number 类型返回 false。 注意: 不建议使用 Number 类型。 String 类型 String 类型是原始类型 string 类型对应的包装类型。 var str = new String(\"hello world\"); String 类型与 string 类型的区别: typeof 运算符对原始类型返回 string，而对包装类型为 object。 instanceof 运算符测试 String 类型返回 true，而测试 string 类型返回 false。 注意: 不建议使用 String 类型。 instanceof 运算符 instanceof 运算符的左操作数是一个包装类型的变量，右操作数是对应的数据类型。如果左侧的变量是右侧的数据类型，则表达式返回 true；否则返回 false。 例如下述示例代码: var str = \"this is message\"; str instanceof String;// 计算结果为 true, str是String类型 str instanceof Object;// 计算结果为 true, 所有包装类型都是Object的实例 str instanceof Number;// 计算结果为 false 注意: 所有对象都是 Object 类型的实例对象，通过 instanceof 运算符判断一个对象是否为具体数据类型，也包含\"父类\"。（后面课程会学习） Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 19:38:57 "},"chapter4/special-type.html":{"url":"chapter4/special-type.html","title":"第四节 特殊类型","keywords":"","body":"undefined 和 null 值都是 JavaScript 中的特殊类型。在实际开发中，这两个特殊类型也是经常出现错误的地方。尤其是 null 值。 undefined JavaScript 中有两个表示空的数据类型，undefined 和 null，其中比较有用的是 undefined。 undefined 类型只有一个值，就是 undefined。 下列情况会返回 undefined: 访问未修改的变量 undefined。 没有定义 return 表达式的函数隐式返回 undefined。 return 表达式没有显式的返回任何内容。 访问不存在的属性。 任何被设置为 undefined 值的变量。 null null 值是 JavaScript 中的一个特殊类型，用于表示一个不再指向任何内存空间地址的变量。 null 值多用于释放 JavaScript 中的资源（变量、数组和函数等）。 注意: 使用 typeof 运算符计算 null 的话，返回的是 object。 var longestory = null; console.log(longestory);// 输出 null undefined 与 null undefined 与 null 的共同点是它们都是原始类型，保存在栈中。 而不同点是: undefined: 表示变量声明但未被赋值，是所有未赋值变量的默认值。一般很少主动使用。 null: 表示一个没有指向任何内存地址的变量，将来可能指向某个具体内存地址。一般用于主动释放资源。 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 19:44:54 "},"chapter4/type-conversion.html":{"url":"chapter4/type-conversion.html","title":"第五节 类型转换","keywords":"","body":"数据类型转换，也是使用 JavaScript 语言编程进行遇到的操作，尤其是隐世类型转换。 隐式类型转换 由于 JavaScript 是弱类型/松散类型的，在任何情况下都可以强制转换。 1. 转换为字符串: 将一个值加上空字符串可以轻松转换为字符串类型。 '' + 10 === '10'; // true 2. 转换为数字: 使用一元的加号操作符，可以把字符串转换为数字。 +'10' === 10; // true 3. 转换为布尔值: 使用否操作符两次，可以把一个值转换为布尔型。 !!'foo'; // true 显式类型转换 1. 使用 JavaScript 的包装类型的构造函数进行类型转换。 构造函数 描述 Number() 将字符串或布尔值转换为数字，如果包含非法字符，则返回 NaN String() 将数字或布尔值转换为字符串 Boolean() 将字符串或数字转换为布尔值 2. 使用数据类型的转换函数进行类型转换。 构造函数 描述 toString() 将数字或布尔值转换为字符串 parseInt() 将字符串或布尔值转换为整数类型 parseFloat() 将字符串或布尔值转换为浮点类型 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-12 19:50:15 "},"chapter5/operator-summary.html":{"url":"chapter5/operator-summary.html","title":"第一节 什么是运算符","keywords":"","body":"第一节 什么是运算符 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter5/arithmetic-operator.html":{"url":"chapter5/arithmetic-operator.html","title":"第二节 算数运算符","keywords":"","body":"第二节 算数运算符 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter5/comparison-operator.html":{"url":"chapter5/comparison-operator.html","title":"第三节 比较运算符","keywords":"","body":"第三节 比较运算符 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter5/logical-operator.html":{"url":"chapter5/logical-operator.html","title":"第四节 逻辑运算符","keywords":"","body":"第四节 逻辑运算符 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter5/bitwise-operator.html":{"url":"chapter5/bitwise-operator.html","title":"第五节 按位运算符","keywords":"","body":"第五节 按位运算符 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter5/assign-operator.html":{"url":"chapter5/assign-operator.html","title":"第六节 赋值运算符","keywords":"","body":"第六节 赋值运算符 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter5/string-concatenation-operator.html":{"url":"chapter5/string-concatenation-operator.html","title":"第七节 字符串连接运算符","keywords":"","body":"第七节 字符串连接运算符 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter5/conditional-operator.html":{"url":"chapter5/conditional-operator.html","title":"第八节 条件运算符","keywords":"","body":"第八节 条件运算符 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter6/statement-summary.html":{"url":"chapter6/statement-summary.html","title":"第一节 什么是语句","keywords":"","body":"第一节 什么是语句 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter6/conditional-statement.html":{"url":"chapter6/conditional-statement.html","title":"第二节 条件语句","keywords":"","body":"第二节 条件语句 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter6/loop-conditional.html":{"url":"chapter6/loop-conditional.html","title":"第三节 循环语句","keywords":"","body":"第三节 循环语句 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter6/goto-conditional.html":{"url":"chapter6/goto-conditional.html","title":"第四节 跳转语句","keywords":"","body":"第四节 跳转语句 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter7/array-summary.html":{"url":"chapter7/array-summary.html","title":"第一节 什么是数组","keywords":"","body":"第一节 什么是数组 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter7/one-dimensional-array.html":{"url":"chapter7/one-dimensional-array.html","title":"第二节 一维数组","keywords":"","body":"第二节 一维数组 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter7/two-dimensional-array.html":{"url":"chapter7/two-dimensional-array.html","title":"第三节 二维数组","keywords":"","body":"第三节 二维数组 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter8/function-summary.html":{"url":"chapter8/function-summary.html","title":"第一节 什么是函数","keywords":"","body":"第一节 什么是函数 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter8/function.html":{"url":"chapter8/function.html","title":"第二节 函数","keywords":"","body":"第二节 函数 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter8/predefined-function.html":{"url":"chapter8/predefined-function.html","title":"第三节 预定义函数","keywords":"","body":"第三节 预定义函数 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter9/scope-summary.html":{"url":"chapter9/scope-summary.html","title":"第一节 什么是作用域","keywords":"","body":"第一节 什么是作用域 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter9/variable-scope.html":{"url":"chapter9/variable-scope.html","title":"第二节 变量作用域","keywords":"","body":"第二节 变量作用域 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter9/function-scope.html":{"url":"chapter9/function-scope.html","title":"第三节 函数作用域","keywords":"","body":"第三节 函数作用域 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter10/object-summary.html":{"url":"chapter10/object-summary.html","title":"第一节 什么是对象","keywords":"","body":"第一节 什么是对象 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter10/object-object.html":{"url":"chapter10/object-object.html","title":"第二节 Object 对象","keywords":"","body":"第二节 Object 对象 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter10/create-object.html":{"url":"chapter10/create-object.html","title":"第三节 创建对象","keywords":"","body":"第三节 创建对象 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter10/attribute-of-object.html":{"url":"chapter10/attribute-of-object.html","title":"第四节 对象的属性","keywords":"","body":"第四节 对象的属性 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "},"chapter10/function-of-object.html":{"url":"chapter10/function-of-object.html","title":"第五节 对象的方法","keywords":"","body":"第五节 对象的方法 Copyright © www.longestory.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-01-11 21:26:16 "}}